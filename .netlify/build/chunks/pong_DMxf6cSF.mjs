import { a as createComponent, r as renderTemplate, m as maybeRenderHead, u as unescapeHTML } from './astro/server_ogrvkZIj.mjs';
import 'kleur/colors';
import 'clsx';

const html = "<h2 id=\"what-is-pong\">What is Pong?</h2>\n<p>Pong is an electronic game of tennis, so to speak. It was released by Atari in 1972. While the first electronic version of tennis was a game called Tennis for Two, dating back to 1958, Pong was one of the first mainstream video games to appear in arcade cabinet form.</p>\n<p>Pong is a game that consists of 2 players, each equipped with a paddle. The goal is to bounce the ball off of your paddle so it doesn’t go out of bounds on your side. You score points for every ball you hit over the other players side of the court.</p>\n<h2 id=\"the-basics\">The basics</h2>\n<p>In our version of Pong we will be using the web browser and Typescript to code the game.\r\nThe first step is setting up a HTML file with the appropriate link to the converted Javascript file.\r\nBut I thought you said we were using Typescript?  We are, but most browsers can’t run Typescript natively.\r\nBy converting the Typescript (.ts) file into Javascript (.js) we create something that the browser can interpret.</p>\n<p>We will also need to include links to out CSS file as well as create a SVG with elements for our board, ball, paddles, and score.</p>\n<p>An SVG?</p>\n<p>Yes that.</p>\n<p>An SVG is a Scalable Vector Graphics format that makes images out of elements similar to HTML. It can also use complex math to make shapes.</p>\n<p>So why an SVG instead of a JPG or PNG?</p>\n<p>SVG allows for us to define the elements of the board and all game pieces as well as manipulate their positions.\r\nBeing able to do this directly is much easier that importing multiple images for each part of the game board.\r\nIt also allows us to practice SVG manipulation, which can be an essential skill for Frontend Development.</p>\n<h2 id=\"game-logic\">Game logic</h2>\n<p>This can be broken into a few major parts. There’s the game engine which is the main loop that repeats until game over.\r\nThere’s the input handler, which checks for input from the user moves the paddles.\r\nThere’s the ball which moves based on a velocity along the x and y axis.\r\nThe movement is handled in the game loop but the trajectory is calculated upon impact.\r\nThere’s the bounds detection / collision detection which handles any contact with the ball.\r\nAnd finally there is a “AI” component for the player to play against in single player.</p>\n<p>The input handler, collision detection, and score are all called from the game loop once per loop.\r\nThis ensures that every frame is accurate and responsive.</p>\n<p><strong>I might add an await to the input handler and make it asynchronous for responsiveness.</strong></p>\n<p>The logic is simple, if the ball hits a paddle or the top or bottom wall then it bounces, otherwise it is a point for the opposite side.\r\nOnce the ball is out of bounds and the point is score it should be reset and cast toward the opposing team.</p>\n<h3 id=\"collision-detection\">Collision Detection</h3>\n<p>Collision detection should be performed on movement since this is the only time that collision could happen.\r\nLogically speaking, collision can only happen after a movement, thus we check after each movement or frame update.</p>\n<h4 id=\"box-collision\">Box collision</h4>\n<p>If we think of the ball and paddles as a box then we can see if the balls outer most point is in conflict with that of the paddles.\r\nA box has a range on the x and y axis. If the left most point on the box is within the range of another object then we have a collision.</p>\n<p>This is a very simple form of collision detection that can be used on the x and y axis. The limitation being that a curve would require a bit more checking to see if there is in fact a collision.</p>\n<h4 id=\"bounds-collision\">Bounds Collision</h4>\n<p>Using the same box collision for the ball and a fixed x and y position, we can figure out if the ball is in bounds or not.\r\nIf we set the game board as starting at 0,0 and ending at 100,100 and we have a ball that is 5 in size then we can check for collisions.\r\nFor instance, if the ball is at position 99,20 then we can say that there is a collision on the right side since 99+5 is 104 and is outside of the bounds of the board.</p>\n<h4 id=\"directional-collision-detection\">Directional Collision Detection</h4>\n<p>Since we know the direction of the ball’s movement we only need to check for collisions on the side of the direction of travel. If we are moving to the left, then there is no need to check for collision on the right side.\r\nThe ball moves to the right on a left collision with the paddle, thus we no longer need to check the left side while moving towards the right.\r\nFor simplicity, collision detection should only check on the directions of motion of any object.</p>\n<h4 id=\"collision-detection-function\">Collision Detection Function</h4>\n<p>We need to pass in the direction of travel, the range on the x and the range of the y of the object, and the x and y range of any object to be tested against.</p>\n<p>This could look something like\r\n<code>detect( direction, objectX, objectY, paddleX, paddleY)</code></p>\n<p>Since the paddles have a fixed x location and a varying y location, we can also forgo the paddleX.\r\n<code>detect( direction, objectX, objectY, paddleLeftY, paddleRightY )</code></p>\n<p>This can use the direction to check for the left or right paddle. This might seem a bit wasteful though sending needless information through.</p>\n<p>We could also use  <code>detect( object1X, object1Y, object2X, object2Y )</code>, which would be more generic and slightly less efficient.</p>\n<p>How about <code>detect( direction, object1COORD, object2COORD )</code>?\r\nThis still passes in unused information, however, we can treat the COORD positions as a tuple type and keep the information useful since it has to exist anyway.</p>\n<h3 id=\"score\">Score</h3>\n<p>Since we know how collision detextion works, we can then set the logic to trigger a score event into the collision detection.</p>\n<p>The collision detection on the left and right bounds need to trigger a score for the right or left player respectively.\r\nSo basically we can add logic that the ball going out of the right bounds would score a point for the left player. This would then trigger a score update, thus incrementing the plaer’s score by a predetermined amount.</p>\n<p>Since our score is updating, it also makes sense to call a function to redraw or update the score.</p>";

				const frontmatter = {"title":"Building Pong","description":"Building pong using Typescript, CSS, and SVGs"};
				const file = "C:/Users/meatw/source/repos/brunscii/astro-blog-site/src/content/blog/pong/pong.md";
				const url = undefined;
				function rawContent() {
					return "\r\n## What is Pong?\r\n\r\nPong is an electronic game of tennis, so to speak. It was released by Atari in 1972. While the first electronic version of tennis was a game called Tennis for Two, dating back to 1958, Pong was one of the first mainstream video games to appear in arcade cabinet form.\r\n\r\nPong is a game that consists of 2 players, each equipped with a paddle. The goal is to bounce the ball off of your paddle so it doesn't go out of bounds on your side. You score points for every ball you hit over the other players side of the court. \r\n\r\n## The basics\r\n\r\nIn our version of Pong we will be using the web browser and Typescript to code the game.\r\nThe first step is setting up a HTML file with the appropriate link to the converted Javascript file. \r\nBut I thought you said we were using Typescript?  We are, but most browsers can't run Typescript natively.\r\nBy converting the Typescript (.ts) file into Javascript (.js) we create something that the browser can interpret. \r\n\r\nWe will also need to include links to out CSS file as well as create a SVG with elements for our board, ball, paddles, and score.\r\n\r\nAn SVG?\r\n\r\nYes that. \r\n\r\nAn SVG is a Scalable Vector Graphics format that makes images out of elements similar to HTML. It can also use complex math to make shapes. \r\n\r\nSo why an SVG instead of a JPG or PNG?\r\n\r\nSVG allows for us to define the elements of the board and all game pieces as well as manipulate their positions. \r\nBeing able to do this directly is much easier that importing multiple images for each part of the game board. \r\nIt also allows us to practice SVG manipulation, which can be an essential skill for Frontend Development.\r\n\r\n## Game logic\r\n\r\nThis can be broken into a few major parts. There's the game engine which is the main loop that repeats until game over.\r\nThere's the input handler, which checks for input from the user moves the paddles.\r\nThere's the ball which moves based on a velocity along the x and y axis. \r\nThe movement is handled in the game loop but the trajectory is calculated upon impact.\r\nThere's the bounds detection / collision detection which handles any contact with the ball.\r\nAnd finally there is a \"AI\" component for the player to play against in single player.\r\n\r\nThe input handler, collision detection, and score are all called from the game loop once per loop. \r\nThis ensures that every frame is accurate and responsive.\r\n\r\n**I might add an await to the input handler and make it asynchronous for responsiveness.**\r\n\r\nThe logic is simple, if the ball hits a paddle or the top or bottom wall then it bounces, otherwise it is a point for the opposite side.\r\nOnce the ball is out of bounds and the point is score it should be reset and cast toward the opposing team.\r\n\r\n### Collision Detection\r\n\r\nCollision detection should be performed on movement since this is the only time that collision could happen. \r\nLogically speaking, collision can only happen after a movement, thus we check after each movement or frame update.\r\n\r\n#### Box collision\r\n\r\nIf we think of the ball and paddles as a box then we can see if the balls outer most point is in conflict with that of the paddles. \r\nA box has a range on the x and y axis. If the left most point on the box is within the range of another object then we have a collision.\r\n\r\nThis is a very simple form of collision detection that can be used on the x and y axis. The limitation being that a curve would require a bit more checking to see if there is in fact a collision. \r\n\r\n#### Bounds Collision\r\n\r\nUsing the same box collision for the ball and a fixed x and y position, we can figure out if the ball is in bounds or not. \r\nIf we set the game board as starting at 0,0 and ending at 100,100 and we have a ball that is 5 in size then we can check for collisions. \r\nFor instance, if the ball is at position 99,20 then we can say that there is a collision on the right side since 99+5 is 104 and is outside of the bounds of the board.\r\n\r\n#### Directional Collision Detection\r\n\r\nSince we know the direction of the ball's movement we only need to check for collisions on the side of the direction of travel. If we are moving to the left, then there is no need to check for collision on the right side. \r\nThe ball moves to the right on a left collision with the paddle, thus we no longer need to check the left side while moving towards the right. \r\nFor simplicity, collision detection should only check on the directions of motion of any object.\r\n\r\n#### Collision Detection Function\r\n\r\nWe need to pass in the direction of travel, the range on the x and the range of the y of the object, and the x and y range of any object to be tested against. \r\n\r\nThis could look something like \r\n```detect( direction, objectX, objectY, paddleX, paddleY)```\r\n\r\nSince the paddles have a fixed x location and a varying y location, we can also forgo the paddleX.\r\n``` detect( direction, objectX, objectY, paddleLeftY, paddleRightY ) ```\r\n\r\nThis can use the direction to check for the left or right paddle. This might seem a bit wasteful though sending needless information through.\r\n\r\nWe could also use  `detect( object1X, object1Y, object2X, object2Y )`, which would be more generic and slightly less efficient. \r\n\r\nHow about ``` detect( direction, object1COORD, object2COORD ) ```?\r\nThis still passes in unused information, however, we can treat the COORD positions as a tuple type and keep the information useful since it has to exist anyway. \r\n\r\n### Score\r\n\r\nSince we know how collision detextion works, we can then set the logic to trigger a score event into the collision detection. \r\n\r\nThe collision detection on the left and right bounds need to trigger a score for the right or left player respectively.\r\nSo basically we can add logic that the ball going out of the right bounds would score a point for the left player. This would then trigger a score update, thus incrementing the plaer's score by a predetermined amount.\r\n\r\nSince our score is updating, it also makes sense to call a function to redraw or update the score. ";
				}
				function compiledContent() {
					return html;
				}
				function getHeadings() {
					return [{"depth":2,"slug":"what-is-pong","text":"What is Pong?"},{"depth":2,"slug":"the-basics","text":"The basics"},{"depth":2,"slug":"game-logic","text":"Game logic"},{"depth":3,"slug":"collision-detection","text":"Collision Detection"},{"depth":4,"slug":"box-collision","text":"Box collision"},{"depth":4,"slug":"bounds-collision","text":"Bounds Collision"},{"depth":4,"slug":"directional-collision-detection","text":"Directional Collision Detection"},{"depth":4,"slug":"collision-detection-function","text":"Collision Detection Function"},{"depth":3,"slug":"score","text":"Score"}];
				}

				const Content = createComponent((result, _props, slots) => {
					const { layout, ...content } = frontmatter;
					content.file = file;
					content.url = url;

					return renderTemplate`${maybeRenderHead()}${unescapeHTML(html)}`;
				});

export { Content, compiledContent, Content as default, file, frontmatter, getHeadings, rawContent, url };
