import { a as createComponent, r as renderTemplate, m as maybeRenderHead, u as unescapeHTML } from './astro/server_ogrvkZIj.mjs';
import 'kleur/colors';
import 'clsx';

const html = "<!-- # GREP -->\n<h2 id=\"what-is-grep\">What is GREP</h2>\n<p><strong>GREP</strong> stands for <strong>G</strong>lobal <strong>R</strong>egular <strong>E</strong>xpresion <strong>P</strong>rint. While the name does sound like grep would actually\r\nprint out regular expressions, or regex for short, but it actually prints out matches to those regular expressions.</p>\n<p>Grep a powerful yet rarely understood tool that is used to match patterns.</p>\n<p>According to grep’s built-in <code>--help</code> function, this is the structure of grep.</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\"><code><span class=\"line\"><span>Usage: grep [OPTION]... PATTERNS [FILE]...</span></span>\n<span class=\"line\"><span>Search for PATTERNS in each FILE.</span></span>\n<span class=\"line\"><span>Example: grep -i 'hello world' menu.h main.c</span></span>\n<span class=\"line\"><span>PATTERNS can contain multiple patterns separated by newlines.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>Pattern selection and interpretation:</span></span>\n<span class=\"line\"><span>-E, --extended-regexp     PATTERNS are extended regular expressions</span></span>\n<span class=\"line\"><span>-F, --fixed-strings       PATTERNS are strings</span></span>\n<span class=\"line\"><span>-G, --basic-regexp        PATTERNS are basic regular expressions</span></span>\n<span class=\"line\"><span>-P, --perl-regexp         PATTERNS are Perl regular expressions</span></span>\n<span class=\"line\"><span>-e, --regexp=PATTERNS     use PATTERNS for matching</span></span>\n<span class=\"line\"><span>-f, --file=FILE           take PATTERNS from FILE</span></span>\n<span class=\"line\"><span>-i, --ignore-case         ignore case distinctions in patterns and data</span></span>\n<span class=\"line\"><span>    --no-ignore-case      do not ignore case distinctions (default)</span></span>\n<span class=\"line\"><span>-w, --word-regexp         match only whole words</span></span>\n<span class=\"line\"><span>-x, --line-regexp         match only whole lines</span></span>\n<span class=\"line\"><span>-z, --null-data           a data line ends in 0 byte, not newline</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>Miscellaneous:</span></span>\n<span class=\"line\"><span>-s, --no-messages         suppress error messages</span></span>\n<span class=\"line\"><span>-v, --invert-match        select non-matching lines</span></span>\n<span class=\"line\"><span>-V, --version             display version information and exit</span></span>\n<span class=\"line\"><span>    --help                display this help text and exit</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>Output control:</span></span>\n<span class=\"line\"><span>-m, --max-count=NUM       stop after NUM selected lines</span></span>\n<span class=\"line\"><span>-b, --byte-offset         print the byte offset with output lines</span></span>\n<span class=\"line\"><span>-n, --line-number         print line number with output lines</span></span>\n<span class=\"line\"><span>    --line-buffered       flush output on every line</span></span>\n<span class=\"line\"><span>-H, --with-filename       print file name with output lines</span></span>\n<span class=\"line\"><span>-h, --no-filename         suppress the file name prefix on output</span></span>\n<span class=\"line\"><span>    --label=LABEL         use LABEL as the standard input file name prefix</span></span>\n<span class=\"line\"><span>-o, --only-matching       show only nonempty parts of lines that match</span></span>\n<span class=\"line\"><span>-q, --quiet, --silent     suppress all normal output</span></span>\n<span class=\"line\"><span>    --binary-files=TYPE   assume that binary files are TYPE;</span></span>\n<span class=\"line\"><span>                            TYPE is 'binary', 'text', or 'without-match'</span></span>\n<span class=\"line\"><span>-a, --text                equivalent to --binary-files=text</span></span>\n<span class=\"line\"><span>-I                        equivalent to --binary-files=without-match</span></span>\n<span class=\"line\"><span>-d, --directories=ACTION  how to handle directories;</span></span>\n<span class=\"line\"><span>                            ACTION is 'read', 'recurse', or 'skip'</span></span>\n<span class=\"line\"><span>-D, --devices=ACTION      how to handle devices, FIFOs and sockets;</span></span>\n<span class=\"line\"><span>                            ACTION is 'read' or 'skip'</span></span>\n<span class=\"line\"><span>-r, --recursive           like --directories=recurse</span></span>\n<span class=\"line\"><span>-R, --dereference-recursive  likewise, but follow all symlinks</span></span>\n<span class=\"line\"><span>    --include=GLOB        search only files that match GLOB (a file pattern)</span></span>\n<span class=\"line\"><span>    --exclude=GLOB        skip files that match GLOB</span></span>\n<span class=\"line\"><span>    --exclude-from=FILE   skip files that match any file pattern from FILE</span></span>\n<span class=\"line\"><span>    --exclude-dir=GLOB    skip directories that match GLOB</span></span>\n<span class=\"line\"><span>-L, --files-without-match  print only names of FILEs with no selected lines</span></span>\n<span class=\"line\"><span>-l, --files-with-matches  print only names of FILEs with selected lines</span></span>\n<span class=\"line\"><span>-c, --count               print only a count of selected lines per FILE</span></span>\n<span class=\"line\"><span>-T, --initial-tab         make tabs line up (if needed)</span></span>\n<span class=\"line\"><span>-Z, --null                print 0 byte after FILE name</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>Context control:</span></span>\n<span class=\"line\"><span>-B, --before-context=NUM  print NUM lines of leading context</span></span>\n<span class=\"line\"><span>-A, --after-context=NUM   print NUM lines of trailing context</span></span>\n<span class=\"line\"><span>-C, --context=NUM         print NUM lines of output context</span></span>\n<span class=\"line\"><span>-NUM                      same as --context=NUM</span></span>\n<span class=\"line\"><span>    --color[=WHEN],</span></span>\n<span class=\"line\"><span>    --colour[=WHEN]       use markers to highlight the matching strings;</span></span>\n<span class=\"line\"><span>                            WHEN is 'always', 'never', or 'auto'</span></span>\n<span class=\"line\"><span>-U, --binary              do not strip CR characters at EOL (MSDOS/Windows)</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>When FILE is '-', read standard input.  With no FILE, read '.' if</span></span>\n<span class=\"line\"><span>recursive, '-' otherwise.  With fewer than two FILEs, assume -h.</span></span>\n<span class=\"line\"><span>Exit status is 0 if any line is selected, 1 otherwise;</span></span>\n<span class=\"line\"><span>if any error occurs and -q is not given, the exit status is 2.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>Report bugs to: bug-grep@gnu.org</span></span>\n<span class=\"line\"><span>GNU grep home page: &#x3C;http://www.gnu.org/software/grep/></span></span>\n<span class=\"line\"><span>General help using GNU software: &#x3C;https://www.gnu.org/gethelp/></span></span>\n<span class=\"line\"><span></span></span></code></pre>\n<p>So what if you are a man page user? Well it might look more like this:</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\"><code><span class=\"line\"><span>GREP(1)                                             User Commands                                             GREP(1)</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>NAME</span></span>\n<span class=\"line\"><span>    grep, egrep, fgrep, rgrep - print lines that match patterns</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>SYNOPSIS</span></span>\n<span class=\"line\"><span>    grep [OPTION...] PATTERNS [FILE...]</span></span>\n<span class=\"line\"><span>    grep [OPTION...] -e PATTERNS ... [FILE...]</span></span>\n<span class=\"line\"><span>    grep [OPTION...] -f PATTERN_FILE ... [FILE...]</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>DESCRIPTION</span></span>\n<span class=\"line\"><span>    grep  searches  for  PATTERNS in each FILE.  PATTERNS is one or more patterns separated by newline characters,</span></span>\n<span class=\"line\"><span>    and grep prints each line that matches a pattern.  Typically PATTERNS should be quoted when grep is used in  a</span></span>\n<span class=\"line\"><span>    shell command.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    A  FILE  of  “-”  stands  for  standard  input.   If  no FILE is given, recursive searches examine the working</span></span>\n<span class=\"line\"><span>    directory, and nonrecursive searches read standard input.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    In addition, the variant programs egrep, fgrep and rgrep are  the  same  as  grep -E,  grep -F,  and  grep -r,</span></span>\n<span class=\"line\"><span>    respectively.  These variants are deprecated, but are provided for backward compatibility.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>OPTIONS</span></span>\n<span class=\"line\"><span>Generic Program Information</span></span>\n<span class=\"line\"><span>    --help Output a usage message and exit.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    -V, --version</span></span>\n<span class=\"line\"><span>            Output the version number of grep and exit.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>Pattern Syntax</span></span>\n<span class=\"line\"><span>    -E, --extended-regexp</span></span>\n<span class=\"line\"><span>            Interpret PATTERNS as extended regular expressions (EREs, see below).</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    -F, --fixed-strings</span></span>\n<span class=\"line\"><span>            Interpret PATTERNS as fixed strings, not regular expressions.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    -G, --basic-regexp</span></span>\n<span class=\"line\"><span>            Interpret PATTERNS as basic regular expressions (BREs, see below).  This is the default.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    -P, --perl-regexp</span></span>\n<span class=\"line\"><span>            Interpret  PATTERNS  as  Perl-compatible regular expressions (PCREs).  This option is experimental when</span></span>\n<span class=\"line\"><span>            combined with the -z (--null-data) option, and grep -P may warn of unimplemented features.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>Matching Control</span></span>\n<span class=\"line\"><span>    -e PATTERNS, --regexp=PATTERNS</span></span>\n<span class=\"line\"><span>            Use PATTERNS as the patterns.  If this option is used  multiple  times  or  is  combined  with  the  -f</span></span>\n<span class=\"line\"><span>            (--file) option, search for all patterns given.  This option can be used to protect a pattern beginning</span></span>\n<span class=\"line\"><span>            with “-”.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    -f FILE, --file=FILE</span></span>\n<span class=\"line\"><span>            Obtain patterns from FILE, one per line.  If this option is used multiple times or is combined with the</span></span>\n<span class=\"line\"><span>            -e  (--regexp)  option,  search  for  all  patterns  given.  The empty file contains zero patterns, and</span></span>\n<span class=\"line\"><span>            therefore matches nothing.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    -i, --ignore-case</span></span>\n<span class=\"line\"><span>            Ignore case distinctions in patterns and input data, so that characters that differ only in case  match</span></span>\n<span class=\"line\"><span>            each other.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    --no-ignore-case</span></span>\n<span class=\"line\"><span>            Do  not  ignore  case  distinctions  in  patterns and input data.  This is the default.  This option is</span></span>\n<span class=\"line\"><span>            useful for passing to shell scripts that already use -i, to cancel its effects because the two  options</span></span>\n<span class=\"line\"><span>            override each other.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    -v, --invert-match</span></span>\n<span class=\"line\"><span>            Invert the sense of matching, to select non-matching lines.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    -w, --word-regexp</span></span>\n<span class=\"line\"><span>            Select  only  those  lines  containing  matches  that  form whole words.  The test is that the matching</span></span>\n<span class=\"line\"><span>            substring must either be at the beginning of the line, or preceded by a non-word constituent character.</span></span>\n<span class=\"line\"><span>            Similarly,  it  must  be either at the end of the line or followed by a non-word constituent character.</span></span>\n<span class=\"line\"><span>            Word-constituent characters are letters, digits, and the underscore.  This option has no effect  if  -x</span></span>\n<span class=\"line\"><span>            is also specified.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    -x, --line-regexp</span></span>\n<span class=\"line\"><span>            Select only those matches that exactly match the whole line.  For a regular expression pattern, this is</span></span>\n<span class=\"line\"><span>            like parenthesizing the pattern and then surrounding it with ^ and $.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    -y     Obsolete synonym for -i.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>General Output Control</span></span>\n<span class=\"line\"><span>    -c, --count</span></span>\n<span class=\"line\"><span>            Suppress normal output; instead print a count of matching lines for each  input  file.   With  the  -v,</span></span>\n<span class=\"line\"><span>            --invert-match option (see below), count non-matching lines.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    --color[=WHEN], --colour[=WHEN]</span></span>\n<span class=\"line\"><span>            Surround the matched (non-empty) strings, matching lines, context lines, file names, line numbers, byte</span></span>\n<span class=\"line\"><span>            offsets, and separators (for fields and groups of context lines) with escape sequences to display  them</span></span>\n<span class=\"line\"><span>            in  color  on  the  terminal.   The  colors  are  defined by the environment variable GREP_COLORS.  The</span></span>\n<span class=\"line\"><span>            deprecated environment variable GREP_COLOR is still supported, but its setting does not have  priority.</span></span>\n<span class=\"line\"><span>            WHEN is never, always, or auto.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    -L, --files-without-match</span></span>\n<span class=\"line\"><span>            Suppress  normal  output; instead print the name of each input file from which no output would normally</span></span>\n<span class=\"line\"><span>            have been printed.  The scanning will stop on the first match.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    -l, --files-with-matches</span></span>\n<span class=\"line\"><span>            Suppress normal output; instead print the name of each input file from which output would normally have</span></span>\n<span class=\"line\"><span>            been printed.  The scanning will stop on the first match.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    -m NUM, --max-count=NUM</span></span>\n<span class=\"line\"><span>            Stop  reading a file after NUM matching lines.  If the input is standard input from a regular file, and</span></span>\n<span class=\"line\"><span>            NUM matching lines are output, grep ensures that the standard input is positioned  to  just  after  the</span></span>\n<span class=\"line\"><span>            last  matching line before exiting, regardless of the presence of trailing context lines.  This enables</span></span>\n<span class=\"line\"><span>            a calling process to resume a search.  When grep  stops  after  NUM  matching  lines,  it  outputs  any</span></span>\n<span class=\"line\"><span>            trailing  context  lines.   When  the  -c  or --count option is also used, grep does not output a count</span></span>\n<span class=\"line\"><span>            greater than NUM.  When the -v or --invert-match option is also used, grep stops after  outputting  NUM</span></span>\n<span class=\"line\"><span>            non-matching lines.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    -o, --only-matching</span></span>\n<span class=\"line\"><span>            Print  only  the matched (non-empty) parts of a matching line, with each such part on a separate output</span></span>\n<span class=\"line\"><span>            line.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    -q, --quiet, --silent</span></span>\n<span class=\"line\"><span>            Quiet; do not write anything to standard output.  Exit immediately with zero status  if  any  match  is</span></span>\n<span class=\"line\"><span>            found, even if an error was detected.  Also see the -s or --no-messages option.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    -s, --no-messages</span></span>\n<span class=\"line\"><span>            Suppress error messages about nonexistent or unreadable files.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>Output Line Prefix Control</span></span>\n<span class=\"line\"><span>    -b, --byte-offset</span></span>\n<span class=\"line\"><span>            Print   the   0-based  byte  offset  within  the  input  file  before  each  line  of  output.   If  -o</span></span>\n<span class=\"line\"><span>            (--only-matching) is specified, print the offset of the matching part itself.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    -H, --with-filename</span></span>\n<span class=\"line\"><span>            Print the file name for each match.  This is the default when there is more than one file to search.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    -h, --no-filename</span></span>\n<span class=\"line\"><span>            Suppress the prefixing of file names on output.  This is the default when there is only  one  file  (or</span></span>\n<span class=\"line\"><span>            only standard input) to search.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    --label=LABEL</span></span>\n<span class=\"line\"><span>            Display  input actually coming from standard input as input coming from file LABEL.  This can be useful</span></span>\n<span class=\"line\"><span>            for commands that transform  a  file's  contents  before  searching,  e.g.,  gzip  -cd  foo.gz  |  grep</span></span>\n<span class=\"line\"><span>            --label=foo -H 'some pattern'.  See also the -H option.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    -n, --line-number</span></span>\n<span class=\"line\"><span>            Prefix each line of output with the 1-based line number within its input file.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    -T, --initial-tab</span></span>\n<span class=\"line\"><span>            Make  sure that the first character of actual line content lies on a tab stop, so that the alignment of</span></span>\n<span class=\"line\"><span>            tabs looks normal.  This is useful with options that prefix their output to the actual content:  -H,-n,</span></span>\n<span class=\"line\"><span>            and  -b.   In order to improve the probability that lines from a single file will all start at the same</span></span>\n<span class=\"line\"><span>            column, this also causes the line number and byte offset (if present) to be printed in a  minimum  size</span></span>\n<span class=\"line\"><span>            field width.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    -u, --unix-byte-offsets</span></span>\n<span class=\"line\"><span>            Report  Unix-style  byte offsets.  This switch causes grep to report byte offsets as if the file were a</span></span>\n<span class=\"line\"><span>            Unix-style text file, i.e., with CR characters stripped off.  This will produce  results  identical  to</span></span>\n<span class=\"line\"><span>            running  grep  on  a  Unix machine.  This option has no effect unless -b option is also used; it has no</span></span>\n<span class=\"line\"><span>            effect on platforms other than MS-DOS and MS-Windows.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    -Z, --null</span></span>\n<span class=\"line\"><span>            Output a zero byte (the ASCII NUL character) instead of the character  that  normally  follows  a  file</span></span>\n<span class=\"line\"><span>            name.   For  example,  grep  -lZ outputs a zero byte after each file name instead of the usual newline.</span></span>\n<span class=\"line\"><span>            This option makes the output unambiguous, even  in  the  presence  of  file  names  containing  unusual</span></span>\n<span class=\"line\"><span>            characters  like  newlines.  This option can be used with commands like find -print0, perl -0, sort -z,</span></span>\n<span class=\"line\"><span>            and xargs -0 to process arbitrary file names, even those that contain newline characters.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>Context Line Control</span></span>\n<span class=\"line\"><span>    -A NUM, --after-context=NUM</span></span>\n<span class=\"line\"><span>            Print NUM lines of trailing context after matching lines.  Places a line containing a  group  separator</span></span>\n<span class=\"line\"><span>            (--)  between  contiguous groups of matches.  With the -o or --only-matching option, this has no effect</span></span>\n<span class=\"line\"><span>            and a warning is given.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    -B NUM, --before-context=NUM</span></span>\n<span class=\"line\"><span>            Print NUM lines of leading context before matching lines.  Places a line containing a  group  separator</span></span>\n<span class=\"line\"><span>            (--)  between  contiguous groups of matches.  With the -o or --only-matching option, this has no effect</span></span>\n<span class=\"line\"><span>            and a warning is given.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    -C NUM, -NUM, --context=NUM</span></span>\n<span class=\"line\"><span>            Print NUM lines of output context.  Places a line containing a group separator (--) between  contiguous</span></span>\n<span class=\"line\"><span>            groups of matches.  With the -o or --only-matching option, this has no effect and a warning is given.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>File and Directory Selection</span></span>\n<span class=\"line\"><span>    -a, --text</span></span>\n<span class=\"line\"><span>            Process a binary file as if it were text; this is equivalent to the --binary-files=text option.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    --binary-files=TYPE</span></span>\n<span class=\"line\"><span>            If  a  file's  data or metadata indicate that the file contains binary data, assume that the file is of</span></span>\n<span class=\"line\"><span>            type TYPE.  Non-text bytes indicate binary data; these are either  output  bytes  that  are  improperly</span></span>\n<span class=\"line\"><span>            encoded for the current locale, or null input bytes when the -z option is not given.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>            By  default, TYPE is binary, and grep suppresses output after null input binary data is discovered, and</span></span>\n<span class=\"line\"><span>            suppresses output lines that contain improperly encoded data.  When some  output  is  suppressed,  grep</span></span>\n<span class=\"line\"><span>            follows any output with a one-line message saying that a binary file matches.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>            If  TYPE  is  without-match, when grep discovers null input binary data it assumes that the rest of the</span></span>\n<span class=\"line\"><span>            file does not match; this is equivalent to the -I option.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>            If TYPE is text, grep processes a binary file as if it were text; this is equivalent to the -a option.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>            When type is binary, grep may treat non-text bytes as line terminators  even  without  the  -z  option.</span></span>\n<span class=\"line\"><span>            This  means choosing binary versus text can affect whether a pattern matches a file.  For example, when</span></span>\n<span class=\"line\"><span>            type is binary the pattern q$ might match q immediately followed by a null byte, even  though  this  is</span></span>\n<span class=\"line\"><span>            not  matched when type is text.  Conversely, when type is binary the pattern . (period) might not match</span></span>\n<span class=\"line\"><span>            a null byte.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>            Warning: The -a option might output binary garbage, which can have nasty side effects if the output  is</span></span>\n<span class=\"line\"><span>            a  terminal  and  if  the  terminal  driver interprets some of it as commands.  On the other hand, when</span></span>\n<span class=\"line\"><span>            reading files whose text encodings are unknown, it can be helpful to use -a or to set LC_ALL='C' in the</span></span>\n<span class=\"line\"><span>            environment, in order to find more matches even if the matches are unsafe for direct display.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    -D ACTION, --devices=ACTION</span></span>\n<span class=\"line\"><span>            If  an  input  file is a device, FIFO or socket, use ACTION to process it.  By default, ACTION is read,</span></span>\n<span class=\"line\"><span>            which means that devices are read just as if they were ordinary files.  If ACTION is skip, devices  are</span></span>\n<span class=\"line\"><span>            silently skipped.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    -d ACTION, --directories=ACTION</span></span>\n<span class=\"line\"><span>            If  an  input  file  is  a directory, use ACTION to process it.  By default, ACTION is read, i.e., read</span></span>\n<span class=\"line\"><span>            directories just as if they were ordinary files.  If ACTION is skip,  silently  skip  directories.   If</span></span>\n<span class=\"line\"><span>            ACTION  is  recurse, read all files under each directory, recursively, following symbolic links only if</span></span>\n<span class=\"line\"><span>            they are on the command line.  This is equivalent to the -r option.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    --exclude=GLOB</span></span>\n<span class=\"line\"><span>            Skip any command-line file with a name suffix that matches the pattern GLOB, using wildcard matching; a</span></span>\n<span class=\"line\"><span>            name  suffix  is  either  the  whole  name,  or  a trailing part that starts with a non-slash character</span></span>\n<span class=\"line\"><span>            immediately after a slash (/) in the name.  When searching recursively, skip  any  subfile  whose  base</span></span>\n<span class=\"line\"><span>            name  matches  GLOB; the base name is the part after the last slash.  A pattern can use *, ?, and [...]</span></span>\n<span class=\"line\"><span>            as wildcards, and \\ to quote a wildcard or backslash character literally.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    --exclude-from=FILE</span></span>\n<span class=\"line\"><span>            Skip files whose base name matches any of the file-name globs read from FILE (using  wildcard  matching</span></span>\n<span class=\"line\"><span>            as described under --exclude).</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    --exclude-dir=GLOB</span></span>\n<span class=\"line\"><span>            Skip  any  command-line  directory  with  a  name suffix that matches the pattern GLOB.  When searching</span></span>\n<span class=\"line\"><span>            recursively, skip any subdirectory whose base name matches GLOB.  Ignore any redundant trailing slashes</span></span>\n<span class=\"line\"><span>            in GLOB.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    -I     Process  a  binary  file  as  if  it  did  not  contain  matching  data;  this  is  equivalent  to  the</span></span>\n<span class=\"line\"><span>            --binary-files=without-match option.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    --include=GLOB</span></span>\n<span class=\"line\"><span>            Search only files whose base name matches GLOB (using wildcard matching as described under  --exclude).</span></span>\n<span class=\"line\"><span>            If  contradictory  --include  and  --exclude  options  are  given,  the  last matching one wins.  If no</span></span>\n<span class=\"line\"><span>            --include or --exclude options match, a file is included unless the first such option is --include.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    -r, --recursive</span></span>\n<span class=\"line\"><span>            Read all files under each directory, recursively, following symbolic links only  if  they  are  on  the</span></span>\n<span class=\"line\"><span>            command  line.   Note  that  if no file operand is given, grep searches the working directory.  This is</span></span>\n<span class=\"line\"><span>            equivalent to the -d recurse option.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    -R, --dereference-recursive</span></span>\n<span class=\"line\"><span>            Read all files under each directory, recursively.  Follow all symbolic links, unlike -r.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>Other Options</span></span>\n<span class=\"line\"><span>    --line-buffered</span></span>\n<span class=\"line\"><span>            Use line buffering on output.  This can cause a performance penalty.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    -U, --binary</span></span>\n<span class=\"line\"><span>            Treat the file(s) as binary.  By default, under MS-DOS and MS-Windows, grep guesses whether a  file  is</span></span>\n<span class=\"line\"><span>            text or binary as described for the --binary-files option.  If grep decides the file is a text file, it</span></span>\n<span class=\"line\"><span>            strips the CR characters from the original file contents (to make regular expressions with ^ and $ work</span></span>\n<span class=\"line\"><span>            correctly).   Specifying  -U  overrules  this guesswork, causing all files to be read and passed to the</span></span>\n<span class=\"line\"><span>            matching mechanism verbatim; if the file is a text file with CR/LF pairs at the end of each line,  this</span></span>\n<span class=\"line\"><span>            will  cause some regular expressions to fail.  This option has no effect on platforms other than MS-DOS</span></span>\n<span class=\"line\"><span>            and MS-Windows.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    -z, --null-data</span></span>\n<span class=\"line\"><span>            Treat input and output data as sequences of lines, each terminated  by  a  zero  byte  (the  ASCII  NUL</span></span>\n<span class=\"line\"><span>            character)  instead  of a newline.  Like the -Z or --null option, this option can be used with commands</span></span>\n<span class=\"line\"><span>            like sort -z to process arbitrary file names.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>REGULAR EXPRESSIONS</span></span>\n<span class=\"line\"><span>    A regular expression is a pattern that describes a  set  of  strings.   Regular  expressions  are  constructed</span></span>\n<span class=\"line\"><span>    analogously to arithmetic expressions, by using various operators to combine smaller expressions.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    grep  understands  three  different versions of regular expression syntax: “basic” (BRE), “extended” (ERE) and</span></span>\n<span class=\"line\"><span>    “perl” (PCRE).  In GNU grep there is no difference in  available  functionality  between  basic  and  extended</span></span>\n<span class=\"line\"><span>    syntaxes.   In  other implementations, basic regular expressions are less powerful.  The following description</span></span>\n<span class=\"line\"><span>    applies to extended regular expressions; differences for basic regular expressions are summarized  afterwards.</span></span>\n<span class=\"line\"><span>    Perl-compatible  regular  expressions  give  additional functionality, and are documented in pcresyntax(3) and</span></span>\n<span class=\"line\"><span>    pcrepattern(3), but work only if PCRE is available in the system.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    The fundamental building blocks are the regular expressions that match a single character.   Most  characters,</span></span>\n<span class=\"line\"><span>    including  all  letters  and  digits,  are regular expressions that match themselves.  Any meta-character with</span></span>\n<span class=\"line\"><span>    special meaning may be quoted by preceding it with a backslash.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    The period . matches any single character.  It is unspecified whether it matches an encoding error.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>Character Classes and Bracket Expressions</span></span>\n<span class=\"line\"><span>    A bracket expression is a list of characters enclosed by [ and ].  It matches any  single  character  in  that</span></span>\n<span class=\"line\"><span>    list.   If the first character of the list is the caret ^ then it matches any character not in the list; it is</span></span>\n<span class=\"line\"><span>    unspecified whether it matches an encoding error.  For example, the regular  expression  [0123456789]  matches</span></span>\n<span class=\"line\"><span>    any single digit.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    Within  a bracket expression, a range expression consists of two characters separated by a hyphen.  It matches</span></span>\n<span class=\"line\"><span>    any single character that sorts between the two characters, inclusive, using the locale's  collating  sequence</span></span>\n<span class=\"line\"><span>    and  character  set.   For example, in the default C locale, [a-d] is equivalent to [abcd].  Many locales sort</span></span>\n<span class=\"line\"><span>    characters in dictionary order, and in these locales [a-d] is typically not equivalent to [abcd]; it might  be</span></span>\n<span class=\"line\"><span>    equivalent  to  [aBbCcDd],  for example.  To obtain the traditional interpretation of bracket expressions, you</span></span>\n<span class=\"line\"><span>    can use the C locale by setting the LC_ALL environment variable to the value C.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    Finally, certain named classes of characters are predefined within bracket  expressions,  as  follows.   Their</span></span>\n<span class=\"line\"><span>    names  are  self  explanatory,  and they are [:alnum:], [:alpha:], [:blank:], [:cntrl:], [:digit:], [:graph:],</span></span>\n<span class=\"line\"><span>    [:lower:], [:print:], [:punct:], [:space:], [:upper:], and [:xdigit:].  For  example,  [[:alnum:]]  means  the</span></span>\n<span class=\"line\"><span>    character  class  of  numbers  and  letters  in  the  current locale.  In the C locale and ASCII character set</span></span>\n<span class=\"line\"><span>    encoding, this is the same as [0-9A-Za-z].  (Note that the brackets in these  class  names  are  part  of  the</span></span>\n<span class=\"line\"><span>    symbolic  names,  and  must  be included in addition to the brackets delimiting the bracket expression.)  Most</span></span>\n<span class=\"line\"><span>    meta-characters lose their special meaning inside bracket expressions.  To include a literal ] place it  first</span></span>\n<span class=\"line\"><span>    in  the list.  Similarly, to include a literal ^ place it anywhere but first.  Finally, to include a literal -</span></span>\n<span class=\"line\"><span>    place it last.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>Anchoring</span></span>\n<span class=\"line\"><span>    The caret ^ and the dollar sign $ are  meta-characters  that  respectively  match  the  empty  string  at  the</span></span>\n<span class=\"line\"><span>    beginning and end of a line.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>The Backslash Character and Special Expressions</span></span>\n<span class=\"line\"><span>    The  symbols  \\&#x3C; and \\> respectively match the empty string at the beginning and end of a word.  The symbol \\b</span></span>\n<span class=\"line\"><span>    matches the empty string at the edge of a word, and \\B matches the empty string provided it's not at the  edge</span></span>\n<span class=\"line\"><span>    of a word.  The symbol \\w is a synonym for [_[:alnum:]] and \\W is a synonym for [^_[:alnum:]].</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>Repetition</span></span>\n<span class=\"line\"><span>    A regular expression may be followed by one of several repetition operators:</span></span>\n<span class=\"line\"><span>    ?      The preceding item is optional and matched at most once.</span></span>\n<span class=\"line\"><span>    *      The preceding item will be matched zero or more times.</span></span>\n<span class=\"line\"><span>    +      The preceding item will be matched one or more times.</span></span>\n<span class=\"line\"><span>    {n}    The preceding item is matched exactly n times.</span></span>\n<span class=\"line\"><span>    {n,}   The preceding item is matched n or more times.</span></span>\n<span class=\"line\"><span>    {,m}   The preceding item is matched at most m times.  This is a GNU extension.</span></span>\n<span class=\"line\"><span>    {n,m}  The preceding item is matched at least n times, but not more than m times.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>Concatenation</span></span>\n<span class=\"line\"><span>    Two  regular  expressions  may  be concatenated; the resulting regular expression matches any string formed by</span></span>\n<span class=\"line\"><span>    concatenating two substrings that respectively match the concatenated expressions.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>Alternation</span></span>\n<span class=\"line\"><span>    Two regular expressions may be joined by the infix operator |; the resulting regular  expression  matches  any</span></span>\n<span class=\"line\"><span>    string matching either alternate expression.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>Precedence</span></span>\n<span class=\"line\"><span>    Repetition  takes  precedence  over  concatenation,  which in turn takes precedence over alternation.  A whole</span></span>\n<span class=\"line\"><span>    expression may be enclosed in parentheses to override these precedence rules and form a subexpression.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>Back-references and Subexpressions</span></span>\n<span class=\"line\"><span>    The back-reference \\n, where n is a single  digit,  matches  the  substring  previously  matched  by  the  nth</span></span>\n<span class=\"line\"><span>    parenthesized subexpression of the regular expression.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>Basic vs Extended Regular Expressions</span></span>\n<span class=\"line\"><span>    In  basic regular expressions the meta-characters ?, +, {, |, (, and ) lose their special meaning; instead use</span></span>\n<span class=\"line\"><span>    the backslashed versions \\?, \\+, \\{, \\|, \\(, and \\).</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>EXIT STATUS</span></span>\n<span class=\"line\"><span>    Normally the exit status is 0 if a line is selected, 1 if no lines were selected, and 2 if an error  occurred.</span></span>\n<span class=\"line\"><span>    However,  if  the  -q  or  --quiet or --silent is used and a line is selected, the exit status is 0 even if an</span></span>\n<span class=\"line\"><span>    error occurred.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>ENVIRONMENT</span></span>\n<span class=\"line\"><span>    The behavior of grep is affected by the following environment variables.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    The locale for category LC_foo is specified by examining the three environment variables LC_ALL, LC_foo, LANG,</span></span>\n<span class=\"line\"><span>    in  that order.  The first of these variables that is set specifies the locale.  For example, if LC_ALL is not</span></span>\n<span class=\"line\"><span>    set, but LC_MESSAGES is set to pt_BR, then the  Brazilian  Portuguese  locale  is  used  for  the  LC_MESSAGES</span></span>\n<span class=\"line\"><span>    category.   The  C locale is used if none of these environment variables are set, if the locale catalog is not</span></span>\n<span class=\"line\"><span>    installed, or if grep was not compiled with national language support (NLS).   The  shell  command  locale  -a</span></span>\n<span class=\"line\"><span>    lists locales that are currently available.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    GREP_COLOR</span></span>\n<span class=\"line\"><span>            This  variable  specifies  the  color  used to highlight matched (non-empty) text.  It is deprecated in</span></span>\n<span class=\"line\"><span>            favor of GREP_COLORS, but still supported.  The  mt,  ms,  and  mc  capabilities  of  GREP_COLORS  have</span></span>\n<span class=\"line\"><span>            priority  over  it.  It can only specify the color used to highlight the matching non-empty text in any</span></span>\n<span class=\"line\"><span>            matching line (a selected line when the -v command-line option is omitted, or a context line when -v is</span></span>\n<span class=\"line\"><span>            specified).   The  default  is  01;31, which means a bold red foreground text on the terminal's default</span></span>\n<span class=\"line\"><span>            background.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    GREP_COLORS</span></span>\n<span class=\"line\"><span>            Specifies the colors and other attributes used to highlight various parts of the output.  Its value  is</span></span>\n<span class=\"line\"><span>            a        colon-separated        list        of        capabilities        that        defaults       to</span></span>\n<span class=\"line\"><span>            ms=01;31:mc=01;31:sl=:cx=:fn=35:ln=32:bn=32:se=36 with the  rv  and  ne  boolean  capabilities  omitted</span></span>\n<span class=\"line\"><span>            (i.e., false).  Supported capabilities are as follows.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>            sl=    SGR  substring for whole selected lines (i.e., matching lines when the -v command-line option is</span></span>\n<span class=\"line\"><span>                    omitted, or non-matching lines when -v is specified).  If however the boolean rv capability  and</span></span>\n<span class=\"line\"><span>                    the  -v  command-line  option  are both specified, it applies to context matching lines instead.</span></span>\n<span class=\"line\"><span>                    The default is empty (i.e., the terminal's default color pair).</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>            cx=    SGR substring for whole context lines (i.e., non-matching lines when the -v command-line  option</span></span>\n<span class=\"line\"><span>                    is  omitted,  or matching lines when -v is specified).  If however the boolean rv capability and</span></span>\n<span class=\"line\"><span>                    the -v command-line option are  both  specified,  it  applies  to  selected  non-matching  lines</span></span>\n<span class=\"line\"><span>                    instead.  The default is empty (i.e., the terminal's default color pair).</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>            rv     Boolean  value  that  reverses  (swaps) the meanings of the sl= and cx= capabilities when the -v</span></span>\n<span class=\"line\"><span>                    command-line option is specified.  The default is false (i.e., the capability is omitted).</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>            mt=01;31</span></span>\n<span class=\"line\"><span>                    SGR substring for matching non-empty text in any matching line (i.e., a selected line  when  the</span></span>\n<span class=\"line\"><span>                    -v  command-line  option  is  omitted, or a context line when -v is specified).  Setting this is</span></span>\n<span class=\"line\"><span>                    equivalent to setting both ms= and mc= at once to the same value.  The default  is  a  bold  red</span></span>\n<span class=\"line\"><span>                    text foreground over the current line background.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>            ms=01;31</span></span>\n<span class=\"line\"><span>                    SGR  substring  for  matching non-empty text in a selected line.  (This is only used when the -v</span></span>\n<span class=\"line\"><span>                    command-line option is omitted.)  The effect of the sl= (or cx= if rv) capability remains active</span></span>\n<span class=\"line\"><span>                    when this kicks in.  The default is a bold red text foreground over the current line background.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>            mc=01;31</span></span>\n<span class=\"line\"><span>                    SGR  substring  for  matching  non-empty text in a context line.  (This is only used when the -v</span></span>\n<span class=\"line\"><span>                    command-line option is specified.)  The effect of the cx= (or  sl=  if  rv)  capability  remains</span></span>\n<span class=\"line\"><span>                    active  when  this  kicks  in.   The default is a bold red text foreground over the current line</span></span>\n<span class=\"line\"><span>                    background.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>            fn=35  SGR substring for file names prefixing  any  content  line.   The  default  is  a  magenta  text</span></span>\n<span class=\"line\"><span>                    foreground over the terminal's default background.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>            ln=32  SGR  substring  for  line  numbers  prefixing  any  content  line.   The default is a green text</span></span>\n<span class=\"line\"><span>                    foreground over the terminal's default background.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>            bn=32  SGR substring for byte offsets prefixing  any  content  line.   The  default  is  a  green  text</span></span>\n<span class=\"line\"><span>                    foreground over the terminal's default background.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>            se=36  SGR substring for separators that are inserted between selected line fields (:), between context</span></span>\n<span class=\"line\"><span>                    line fields, (-), and between groups of adjacent lines when nonzero context is  specified  (--).</span></span>\n<span class=\"line\"><span>                    The default is a cyan text foreground over the terminal's default background.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>            ne     Boolean  value  that  prevents  clearing  to  the  end of line using Erase in Line (EL) to Right</span></span>\n<span class=\"line\"><span>                    (\\33[K) each time a colorized item ends.  This is  needed  on  terminals  on  which  EL  is  not</span></span>\n<span class=\"line\"><span>                    supported.   It  is  otherwise  useful on terminals for which the back_color_erase (bce) boolean</span></span>\n<span class=\"line\"><span>                    terminfo capability does not  apply,  when  the  chosen  highlight  colors  do  not  affect  the</span></span>\n<span class=\"line\"><span>                    background,  or when EL is too slow or causes too much flicker.  The default is false (i.e., the</span></span>\n<span class=\"line\"><span>                    capability is omitted).</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>            Note that boolean capabilities have no =... part.  They are omitted (i.e., false) by default and become</span></span>\n<span class=\"line\"><span>            true when specified.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>            See  the  Select Graphic Rendition (SGR) section in the documentation of the text terminal that is used</span></span>\n<span class=\"line\"><span>            for permitted values and their meaning as character attributes.  These substring values are integers in</span></span>\n<span class=\"line\"><span>            decimal  representation  and  can  be  concatenated with semicolons.  grep takes care of assembling the</span></span>\n<span class=\"line\"><span>            result into a complete SGR sequence (\\33[...m).  Common values to concatenate include 1 for bold, 4 for</span></span>\n<span class=\"line\"><span>            underline, 5 for blink, 7 for inverse, 39 for default foreground color, 30 to 37 for foreground colors,</span></span>\n<span class=\"line\"><span>            90 to 97 for 16-color mode foreground colors, 38;5;0 to  38;5;255  for  88-color  and  256-color  modes</span></span>\n<span class=\"line\"><span>            foreground  colors,  49  for  default  background color, 40 to 47 for background colors, 100 to 107 for</span></span>\n<span class=\"line\"><span>            16-color mode background colors, and 48;5;0 to 48;5;255 for 88-color  and  256-color  modes  background</span></span>\n<span class=\"line\"><span>            colors.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    LC_ALL, LC_COLLATE, LANG</span></span>\n<span class=\"line\"><span>            These variables specify the locale for the LC_COLLATE category, which determines the collating sequence</span></span>\n<span class=\"line\"><span>            used to interpret range expressions like [a-z].</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    LC_ALL, LC_CTYPE, LANG</span></span>\n<span class=\"line\"><span>            These variables specify the locale for the LC_CTYPE category, which determines the type of  characters,</span></span>\n<span class=\"line\"><span>            e.g.,  which characters are whitespace.  This category also determines the character encoding, that is,</span></span>\n<span class=\"line\"><span>            whether text is encoded in UTF-8, ASCII, or some other  encoding.   In  the  C  or  POSIX  locale,  all</span></span>\n<span class=\"line\"><span>            characters are encoded as a single byte and every byte is a valid character.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    LC_ALL, LC_MESSAGES, LANG</span></span>\n<span class=\"line\"><span>            These  variables  specify  the  locale for the LC_MESSAGES category, which determines the language that</span></span>\n<span class=\"line\"><span>            grep uses for messages.  The default C locale uses American English messages.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    POSIXLY_CORRECT</span></span>\n<span class=\"line\"><span>            If set, grep behaves as POSIX requires; otherwise, grep behaves more like other  GNU  programs.   POSIX</span></span>\n<span class=\"line\"><span>            requires  that  options  that follow file names must be treated as file names; by default, such options</span></span>\n<span class=\"line\"><span>            are permuted to the front of the operand list and are treated as options.  Also,  POSIX  requires  that</span></span>\n<span class=\"line\"><span>            unrecognized  options  be  diagnosed  as  “illegal”,  but since they are not really against the law the</span></span>\n<span class=\"line\"><span>            default is to diagnose them as “invalid”.  POSIXLY_CORRECT also disables  _N_GNU_nonoption_argv_flags_,</span></span>\n<span class=\"line\"><span>            described below.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    _N_GNU_nonoption_argv_flags_</span></span>\n<span class=\"line\"><span>            (Here N is grep's numeric process ID.)  If the ith character of this environment variable's value is 1,</span></span>\n<span class=\"line\"><span>            do not consider the ith operand of grep to be an option, even if it appears to be one.  A shell can put</span></span>\n<span class=\"line\"><span>            this variable in the environment for each command it runs, specifying which operands are the results of</span></span>\n<span class=\"line\"><span>            file name wildcard expansion and therefore  should  not  be  treated  as  options.   This  behavior  is</span></span>\n<span class=\"line\"><span>            available only with the GNU C library, and only when POSIXLY_CORRECT is not set.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>NOTES</span></span>\n<span class=\"line\"><span>    This man page is maintained only fitfully; the full documentation is often more up-to-date.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>COPYRIGHT</span></span>\n<span class=\"line\"><span>    Copyright 1998-2000, 2002, 2005-2020 Free Software Foundation, Inc.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    This  is  free  software;  see  the  source  for  copying  conditions.   There  is  NO  warranty; not even for</span></span>\n<span class=\"line\"><span>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>BUGS</span></span>\n<span class=\"line\"><span>Reporting Bugs</span></span>\n<span class=\"line\"><span>    Email   bug   reports   to   the    bug-reporting    address    ⟨bug-grep@gnu.org⟩.     An    email    archive</span></span>\n<span class=\"line\"><span>    ⟨https://lists.gnu.org/mailman/listinfo/bug-grep⟩            and            a            bug           tracker</span></span>\n<span class=\"line\"><span>    ⟨https://debbugs.gnu.org/cgi/pkgreport.cgi?package=grep⟩ are available.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>Known Bugs</span></span>\n<span class=\"line\"><span>    Large repetition counts in the {n,m} construct may cause grep to use lots of  memory.   In  addition,  certain</span></span>\n<span class=\"line\"><span>    other obscure regular expressions require exponential time and space, and may cause grep to run out of memory.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    Back-references are very slow, and may require exponential time.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>EXAMPLE</span></span>\n<span class=\"line\"><span>    The  following example outputs the location and contents of any line containing “f” and ending in “.c”, within</span></span>\n<span class=\"line\"><span>    all files in the current directory whose names contain “g” and end in “.h”.  The -n option outputs  line  num‐</span></span>\n<span class=\"line\"><span>    bers,  the -- argument treats expansions of “*g*.h” starting with “-” as file names not options, and the empty</span></span>\n<span class=\"line\"><span>    file /dev/null causes file names to be output even if only one file name happens to be of the form “*g*.h”.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>        $ grep -n -- 'f.*\\.c$' *g*.h /dev/null</span></span>\n<span class=\"line\"><span>        argmatch.h:1:/* definitions and prototypes for argmatch.c</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    The only line that matches is line 1 of argmatch.h.  Note that the regular expression syntax used in the  pat‐</span></span>\n<span class=\"line\"><span>    tern differs from the globbing syntax that the shell uses to match file names.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>SEE ALSO</span></span>\n<span class=\"line\"><span>Regular Manual Pages</span></span>\n<span class=\"line\"><span>    awk(1),  cmp(1),  diff(1),  find(1),  perl(1),  sed(1),  sort(1),  xargs(1),  read(2), pcre(3), pcresyntax(3),</span></span>\n<span class=\"line\"><span>    pcrepattern(3), terminfo(5), glob(7), regex(7).</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>Full Documentation</span></span>\n<span class=\"line\"><span>    A complete manual ⟨https://www.gnu.org/software/grep/manual/⟩ is available.  If the info and grep programs are</span></span>\n<span class=\"line\"><span>    properly installed at your site, the command</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>            info grep</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    should give you access to the complete manual.</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>GNU grep 3.6                                          2019-12-29                                              GREP(1)</span></span>\n<span class=\"line\"><span></span></span></code></pre>\n<h2 id=\"what-is-regex\">What is REGEX</h2>\n<p><strong>Regex</strong>, or <strong>Reg</strong>ular <strong>Ex</strong>pression, is a way of writing search queries that look for specific phrases. A regex expression is a form of pattern matching. For the purpose of this article we will skip the regex tutorial.</p>\n<p>Here are some basics for a recap.</p>\n<h3 id=\"anchors\">Anchors</h3>\n<p>These are expressions that signify a position as a condition. Using one of these means that for there to be a match then you must find the particular phrase in the required position. For example, when we use <code>^</code> we are signifying that the phrase after it must be at the beginning of any match. Say <code>^c</code> would be true for <code>chris</code> but would be false for <code>back</code>. In the first case we have the word <code>chris</code> which begins with a c. This provides a match and thus is true for the regex of <code>^c</code>. Since <code>back</code> only contains a c at the end it does not satisfy the case of <code>^c</code>.</p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th>Expression</th><th>Description</th><th>Example</th></tr></thead><tbody><tr><td>^[exp]</td><td>Start</td><td>^a  - “Hola <u><strong>a</strong></u>migo”</td></tr><tr><td>\\A[exp]</td><td>Start</td><td>\\Aa - “Hola <u><strong>a</strong></u>migo”</td></tr><tr><td>[exp]$</td><td>End</td><td>d$  - “Hello Worl<u><strong>d</strong></u>”</td></tr><tr><td>[exp]\\Z</td><td>End</td><td>d\\Z - “Hello Worl<u><strong>d</strong></u>”</td></tr><tr><td>\\b[exp]\\b</td><td>Word Boundary</td><td>\\bme\\b - “<u><strong>me</strong></u> not some”</td></tr><tr><td>\\B[exp]\\B</td><td>Not Word Boundary</td><td>\\Bme\\B - “Ho<u><strong>me</strong></u>r not me or some”</td></tr></tbody></table>\n<p><em>Note: The use of [exp] is designed to represent a standalone expression. This should not be confused wtih the actual brackets notation.</em></p>\n<p>Let’s look at those work boudaries. They are a bit strange but useful. If a word is a group of letters then a word boundary is the edge of that word. In other words, a letter next to a space would be a word boundary. <code>/b</code> is a word boundary. The side of the expression you apply /b to is the side of the expression that you want a boundary on. If both side have a boundary then you can safely say you are looking for an exact word match. This looks like <code>/bword\\b</code>. If we want a phrase that ends with an expression then we can use <code>[exp]\\b</code>.</p>\n<p>TODO: add some examples of these being demonstrated in the console. Python or JS regex.</p>";

				const frontmatter = {"title":"Grep","description":"Grep reference","pubDate":"1/7/2023","updatedDate":"03/02/2023","draft":false,"category":"Linux Commands"};
				const file = "C:/Users/meatw/source/repos/brunscii/astro-blog-site/src/content/blog/linux_commands/grep.md";
				const url = undefined;
				function rawContent() {
					return "<!-- # GREP -->\r\n\r\n## What is GREP\r\n\r\n**GREP** stands for **G**lobal **R**egular **E**xpresion **P**rint. While the name does sound like grep would actually \r\nprint out regular expressions, or regex for short, but it actually prints out matches to those regular expressions.\r\n\r\nGrep a powerful yet rarely understood tool that is used to match patterns.\r\n\r\nAccording to grep's built-in `--help` function, this is the structure of grep.\r\n\r\n    Usage: grep [OPTION]... PATTERNS [FILE]...\r\n    Search for PATTERNS in each FILE.\r\n    Example: grep -i 'hello world' menu.h main.c\r\n    PATTERNS can contain multiple patterns separated by newlines.\r\n\r\n    Pattern selection and interpretation:\r\n    -E, --extended-regexp     PATTERNS are extended regular expressions\r\n    -F, --fixed-strings       PATTERNS are strings\r\n    -G, --basic-regexp        PATTERNS are basic regular expressions\r\n    -P, --perl-regexp         PATTERNS are Perl regular expressions\r\n    -e, --regexp=PATTERNS     use PATTERNS for matching\r\n    -f, --file=FILE           take PATTERNS from FILE\r\n    -i, --ignore-case         ignore case distinctions in patterns and data\r\n        --no-ignore-case      do not ignore case distinctions (default)\r\n    -w, --word-regexp         match only whole words\r\n    -x, --line-regexp         match only whole lines\r\n    -z, --null-data           a data line ends in 0 byte, not newline\r\n\r\n    Miscellaneous:\r\n    -s, --no-messages         suppress error messages\r\n    -v, --invert-match        select non-matching lines\r\n    -V, --version             display version information and exit\r\n        --help                display this help text and exit\r\n\r\n    Output control:\r\n    -m, --max-count=NUM       stop after NUM selected lines\r\n    -b, --byte-offset         print the byte offset with output lines\r\n    -n, --line-number         print line number with output lines\r\n        --line-buffered       flush output on every line\r\n    -H, --with-filename       print file name with output lines\r\n    -h, --no-filename         suppress the file name prefix on output\r\n        --label=LABEL         use LABEL as the standard input file name prefix\r\n    -o, --only-matching       show only nonempty parts of lines that match\r\n    -q, --quiet, --silent     suppress all normal output\r\n        --binary-files=TYPE   assume that binary files are TYPE;\r\n                                TYPE is 'binary', 'text', or 'without-match'\r\n    -a, --text                equivalent to --binary-files=text\r\n    -I                        equivalent to --binary-files=without-match\r\n    -d, --directories=ACTION  how to handle directories;\r\n                                ACTION is 'read', 'recurse', or 'skip'\r\n    -D, --devices=ACTION      how to handle devices, FIFOs and sockets;\r\n                                ACTION is 'read' or 'skip'\r\n    -r, --recursive           like --directories=recurse\r\n    -R, --dereference-recursive  likewise, but follow all symlinks\r\n        --include=GLOB        search only files that match GLOB (a file pattern)\r\n        --exclude=GLOB        skip files that match GLOB\r\n        --exclude-from=FILE   skip files that match any file pattern from FILE\r\n        --exclude-dir=GLOB    skip directories that match GLOB\r\n    -L, --files-without-match  print only names of FILEs with no selected lines\r\n    -l, --files-with-matches  print only names of FILEs with selected lines\r\n    -c, --count               print only a count of selected lines per FILE\r\n    -T, --initial-tab         make tabs line up (if needed)\r\n    -Z, --null                print 0 byte after FILE name\r\n\r\n    Context control:\r\n    -B, --before-context=NUM  print NUM lines of leading context\r\n    -A, --after-context=NUM   print NUM lines of trailing context\r\n    -C, --context=NUM         print NUM lines of output context\r\n    -NUM                      same as --context=NUM\r\n        --color[=WHEN],\r\n        --colour[=WHEN]       use markers to highlight the matching strings;\r\n                                WHEN is 'always', 'never', or 'auto'\r\n    -U, --binary              do not strip CR characters at EOL (MSDOS/Windows)\r\n\r\n    When FILE is '-', read standard input.  With no FILE, read '.' if\r\n    recursive, '-' otherwise.  With fewer than two FILEs, assume -h.\r\n    Exit status is 0 if any line is selected, 1 otherwise;\r\n    if any error occurs and -q is not given, the exit status is 2.\r\n\r\n    Report bugs to: bug-grep@gnu.org\r\n    GNU grep home page: <http://www.gnu.org/software/grep/>\r\n    General help using GNU software: <https://www.gnu.org/gethelp/>\r\n\r\n\r\nSo what if you are a man page user? Well it might look more like this:\r\n\r\n    GREP(1)                                             User Commands                                             GREP(1)\r\n\r\n    NAME\r\n        grep, egrep, fgrep, rgrep - print lines that match patterns\r\n\r\n    SYNOPSIS\r\n        grep [OPTION...] PATTERNS [FILE...]\r\n        grep [OPTION...] -e PATTERNS ... [FILE...]\r\n        grep [OPTION...] -f PATTERN_FILE ... [FILE...]\r\n\r\n    DESCRIPTION\r\n        grep  searches  for  PATTERNS in each FILE.  PATTERNS is one or more patterns separated by newline characters,\r\n        and grep prints each line that matches a pattern.  Typically PATTERNS should be quoted when grep is used in  a\r\n        shell command.\r\n\r\n        A  FILE  of  “-”  stands  for  standard  input.   If  no FILE is given, recursive searches examine the working\r\n        directory, and nonrecursive searches read standard input.\r\n\r\n        In addition, the variant programs egrep, fgrep and rgrep are  the  same  as  grep -E,  grep -F,  and  grep -r,\r\n        respectively.  These variants are deprecated, but are provided for backward compatibility.\r\n\r\n    OPTIONS\r\n    Generic Program Information\r\n        --help Output a usage message and exit.\r\n\r\n        -V, --version\r\n                Output the version number of grep and exit.\r\n\r\n    Pattern Syntax\r\n        -E, --extended-regexp\r\n                Interpret PATTERNS as extended regular expressions (EREs, see below).\r\n\r\n        -F, --fixed-strings\r\n                Interpret PATTERNS as fixed strings, not regular expressions.\r\n\r\n        -G, --basic-regexp\r\n                Interpret PATTERNS as basic regular expressions (BREs, see below).  This is the default.\r\n\r\n        -P, --perl-regexp\r\n                Interpret  PATTERNS  as  Perl-compatible regular expressions (PCREs).  This option is experimental when\r\n                combined with the -z (--null-data) option, and grep -P may warn of unimplemented features.\r\n\r\n    Matching Control\r\n        -e PATTERNS, --regexp=PATTERNS\r\n                Use PATTERNS as the patterns.  If this option is used  multiple  times  or  is  combined  with  the  -f\r\n                (--file) option, search for all patterns given.  This option can be used to protect a pattern beginning\r\n                with “-”.\r\n\r\n        -f FILE, --file=FILE\r\n                Obtain patterns from FILE, one per line.  If this option is used multiple times or is combined with the\r\n                -e  (--regexp)  option,  search  for  all  patterns  given.  The empty file contains zero patterns, and\r\n                therefore matches nothing.\r\n\r\n        -i, --ignore-case\r\n                Ignore case distinctions in patterns and input data, so that characters that differ only in case  match\r\n                each other.\r\n\r\n        --no-ignore-case\r\n                Do  not  ignore  case  distinctions  in  patterns and input data.  This is the default.  This option is\r\n                useful for passing to shell scripts that already use -i, to cancel its effects because the two  options\r\n                override each other.\r\n\r\n        -v, --invert-match\r\n                Invert the sense of matching, to select non-matching lines.\r\n\r\n        -w, --word-regexp\r\n                Select  only  those  lines  containing  matches  that  form whole words.  The test is that the matching\r\n                substring must either be at the beginning of the line, or preceded by a non-word constituent character.\r\n                Similarly,  it  must  be either at the end of the line or followed by a non-word constituent character.\r\n                Word-constituent characters are letters, digits, and the underscore.  This option has no effect  if  -x\r\n                is also specified.\r\n\r\n        -x, --line-regexp\r\n                Select only those matches that exactly match the whole line.  For a regular expression pattern, this is\r\n                like parenthesizing the pattern and then surrounding it with ^ and $.\r\n\r\n        -y     Obsolete synonym for -i.\r\n\r\n    General Output Control\r\n        -c, --count\r\n                Suppress normal output; instead print a count of matching lines for each  input  file.   With  the  -v,\r\n                --invert-match option (see below), count non-matching lines.\r\n\r\n        --color[=WHEN], --colour[=WHEN]\r\n                Surround the matched (non-empty) strings, matching lines, context lines, file names, line numbers, byte\r\n                offsets, and separators (for fields and groups of context lines) with escape sequences to display  them\r\n                in  color  on  the  terminal.   The  colors  are  defined by the environment variable GREP_COLORS.  The\r\n                deprecated environment variable GREP_COLOR is still supported, but its setting does not have  priority.\r\n                WHEN is never, always, or auto.\r\n\r\n        -L, --files-without-match\r\n                Suppress  normal  output; instead print the name of each input file from which no output would normally\r\n                have been printed.  The scanning will stop on the first match.\r\n\r\n        -l, --files-with-matches\r\n                Suppress normal output; instead print the name of each input file from which output would normally have\r\n                been printed.  The scanning will stop on the first match.\r\n\r\n        -m NUM, --max-count=NUM\r\n                Stop  reading a file after NUM matching lines.  If the input is standard input from a regular file, and\r\n                NUM matching lines are output, grep ensures that the standard input is positioned  to  just  after  the\r\n                last  matching line before exiting, regardless of the presence of trailing context lines.  This enables\r\n                a calling process to resume a search.  When grep  stops  after  NUM  matching  lines,  it  outputs  any\r\n                trailing  context  lines.   When  the  -c  or --count option is also used, grep does not output a count\r\n                greater than NUM.  When the -v or --invert-match option is also used, grep stops after  outputting  NUM\r\n                non-matching lines.\r\n\r\n        -o, --only-matching\r\n                Print  only  the matched (non-empty) parts of a matching line, with each such part on a separate output\r\n                line.\r\n\r\n        -q, --quiet, --silent\r\n                Quiet; do not write anything to standard output.  Exit immediately with zero status  if  any  match  is\r\n                found, even if an error was detected.  Also see the -s or --no-messages option.\r\n\r\n        -s, --no-messages\r\n                Suppress error messages about nonexistent or unreadable files.\r\n\r\n    Output Line Prefix Control\r\n        -b, --byte-offset\r\n                Print   the   0-based  byte  offset  within  the  input  file  before  each  line  of  output.   If  -o\r\n                (--only-matching) is specified, print the offset of the matching part itself.\r\n\r\n        -H, --with-filename\r\n                Print the file name for each match.  This is the default when there is more than one file to search.\r\n\r\n        -h, --no-filename\r\n                Suppress the prefixing of file names on output.  This is the default when there is only  one  file  (or\r\n                only standard input) to search.\r\n\r\n        --label=LABEL\r\n                Display  input actually coming from standard input as input coming from file LABEL.  This can be useful\r\n                for commands that transform  a  file's  contents  before  searching,  e.g.,  gzip  -cd  foo.gz  |  grep\r\n                --label=foo -H 'some pattern'.  See also the -H option.\r\n\r\n        -n, --line-number\r\n                Prefix each line of output with the 1-based line number within its input file.\r\n\r\n        -T, --initial-tab\r\n                Make  sure that the first character of actual line content lies on a tab stop, so that the alignment of\r\n                tabs looks normal.  This is useful with options that prefix their output to the actual content:  -H,-n,\r\n                and  -b.   In order to improve the probability that lines from a single file will all start at the same\r\n                column, this also causes the line number and byte offset (if present) to be printed in a  minimum  size\r\n                field width.\r\n\r\n        -u, --unix-byte-offsets\r\n                Report  Unix-style  byte offsets.  This switch causes grep to report byte offsets as if the file were a\r\n                Unix-style text file, i.e., with CR characters stripped off.  This will produce  results  identical  to\r\n                running  grep  on  a  Unix machine.  This option has no effect unless -b option is also used; it has no\r\n                effect on platforms other than MS-DOS and MS-Windows.\r\n\r\n        -Z, --null\r\n                Output a zero byte (the ASCII NUL character) instead of the character  that  normally  follows  a  file\r\n                name.   For  example,  grep  -lZ outputs a zero byte after each file name instead of the usual newline.\r\n                This option makes the output unambiguous, even  in  the  presence  of  file  names  containing  unusual\r\n                characters  like  newlines.  This option can be used with commands like find -print0, perl -0, sort -z,\r\n                and xargs -0 to process arbitrary file names, even those that contain newline characters.\r\n\r\n    Context Line Control\r\n        -A NUM, --after-context=NUM\r\n                Print NUM lines of trailing context after matching lines.  Places a line containing a  group  separator\r\n                (--)  between  contiguous groups of matches.  With the -o or --only-matching option, this has no effect\r\n                and a warning is given.\r\n\r\n        -B NUM, --before-context=NUM\r\n                Print NUM lines of leading context before matching lines.  Places a line containing a  group  separator\r\n                (--)  between  contiguous groups of matches.  With the -o or --only-matching option, this has no effect\r\n                and a warning is given.\r\n\r\n        -C NUM, -NUM, --context=NUM\r\n                Print NUM lines of output context.  Places a line containing a group separator (--) between  contiguous\r\n                groups of matches.  With the -o or --only-matching option, this has no effect and a warning is given.\r\n\r\n    File and Directory Selection\r\n        -a, --text\r\n                Process a binary file as if it were text; this is equivalent to the --binary-files=text option.\r\n\r\n        --binary-files=TYPE\r\n                If  a  file's  data or metadata indicate that the file contains binary data, assume that the file is of\r\n                type TYPE.  Non-text bytes indicate binary data; these are either  output  bytes  that  are  improperly\r\n                encoded for the current locale, or null input bytes when the -z option is not given.\r\n\r\n                By  default, TYPE is binary, and grep suppresses output after null input binary data is discovered, and\r\n                suppresses output lines that contain improperly encoded data.  When some  output  is  suppressed,  grep\r\n                follows any output with a one-line message saying that a binary file matches.\r\n\r\n                If  TYPE  is  without-match, when grep discovers null input binary data it assumes that the rest of the\r\n                file does not match; this is equivalent to the -I option.\r\n\r\n                If TYPE is text, grep processes a binary file as if it were text; this is equivalent to the -a option.\r\n\r\n                When type is binary, grep may treat non-text bytes as line terminators  even  without  the  -z  option.\r\n                This  means choosing binary versus text can affect whether a pattern matches a file.  For example, when\r\n                type is binary the pattern q$ might match q immediately followed by a null byte, even  though  this  is\r\n                not  matched when type is text.  Conversely, when type is binary the pattern . (period) might not match\r\n                a null byte.\r\n\r\n                Warning: The -a option might output binary garbage, which can have nasty side effects if the output  is\r\n                a  terminal  and  if  the  terminal  driver interprets some of it as commands.  On the other hand, when\r\n                reading files whose text encodings are unknown, it can be helpful to use -a or to set LC_ALL='C' in the\r\n                environment, in order to find more matches even if the matches are unsafe for direct display.\r\n\r\n        -D ACTION, --devices=ACTION\r\n                If  an  input  file is a device, FIFO or socket, use ACTION to process it.  By default, ACTION is read,\r\n                which means that devices are read just as if they were ordinary files.  If ACTION is skip, devices  are\r\n                silently skipped.\r\n\r\n        -d ACTION, --directories=ACTION\r\n                If  an  input  file  is  a directory, use ACTION to process it.  By default, ACTION is read, i.e., read\r\n                directories just as if they were ordinary files.  If ACTION is skip,  silently  skip  directories.   If\r\n                ACTION  is  recurse, read all files under each directory, recursively, following symbolic links only if\r\n                they are on the command line.  This is equivalent to the -r option.\r\n\r\n        --exclude=GLOB\r\n                Skip any command-line file with a name suffix that matches the pattern GLOB, using wildcard matching; a\r\n                name  suffix  is  either  the  whole  name,  or  a trailing part that starts with a non-slash character\r\n                immediately after a slash (/) in the name.  When searching recursively, skip  any  subfile  whose  base\r\n                name  matches  GLOB; the base name is the part after the last slash.  A pattern can use *, ?, and [...]\r\n                as wildcards, and \\ to quote a wildcard or backslash character literally.\r\n\r\n        --exclude-from=FILE\r\n                Skip files whose base name matches any of the file-name globs read from FILE (using  wildcard  matching\r\n                as described under --exclude).\r\n\r\n        --exclude-dir=GLOB\r\n                Skip  any  command-line  directory  with  a  name suffix that matches the pattern GLOB.  When searching\r\n                recursively, skip any subdirectory whose base name matches GLOB.  Ignore any redundant trailing slashes\r\n                in GLOB.\r\n\r\n        -I     Process  a  binary  file  as  if  it  did  not  contain  matching  data;  this  is  equivalent  to  the\r\n                --binary-files=without-match option.\r\n\r\n        --include=GLOB\r\n                Search only files whose base name matches GLOB (using wildcard matching as described under  --exclude).\r\n                If  contradictory  --include  and  --exclude  options  are  given,  the  last matching one wins.  If no\r\n                --include or --exclude options match, a file is included unless the first such option is --include.\r\n\r\n        -r, --recursive\r\n                Read all files under each directory, recursively, following symbolic links only  if  they  are  on  the\r\n                command  line.   Note  that  if no file operand is given, grep searches the working directory.  This is\r\n                equivalent to the -d recurse option.\r\n\r\n        -R, --dereference-recursive\r\n                Read all files under each directory, recursively.  Follow all symbolic links, unlike -r.\r\n\r\n    Other Options\r\n        --line-buffered\r\n                Use line buffering on output.  This can cause a performance penalty.\r\n\r\n        -U, --binary\r\n                Treat the file(s) as binary.  By default, under MS-DOS and MS-Windows, grep guesses whether a  file  is\r\n                text or binary as described for the --binary-files option.  If grep decides the file is a text file, it\r\n                strips the CR characters from the original file contents (to make regular expressions with ^ and $ work\r\n                correctly).   Specifying  -U  overrules  this guesswork, causing all files to be read and passed to the\r\n                matching mechanism verbatim; if the file is a text file with CR/LF pairs at the end of each line,  this\r\n                will  cause some regular expressions to fail.  This option has no effect on platforms other than MS-DOS\r\n                and MS-Windows.\r\n\r\n        -z, --null-data\r\n                Treat input and output data as sequences of lines, each terminated  by  a  zero  byte  (the  ASCII  NUL\r\n                character)  instead  of a newline.  Like the -Z or --null option, this option can be used with commands\r\n                like sort -z to process arbitrary file names.\r\n\r\n    REGULAR EXPRESSIONS\r\n        A regular expression is a pattern that describes a  set  of  strings.   Regular  expressions  are  constructed\r\n        analogously to arithmetic expressions, by using various operators to combine smaller expressions.\r\n\r\n        grep  understands  three  different versions of regular expression syntax: “basic” (BRE), “extended” (ERE) and\r\n        “perl” (PCRE).  In GNU grep there is no difference in  available  functionality  between  basic  and  extended\r\n        syntaxes.   In  other implementations, basic regular expressions are less powerful.  The following description\r\n        applies to extended regular expressions; differences for basic regular expressions are summarized  afterwards.\r\n        Perl-compatible  regular  expressions  give  additional functionality, and are documented in pcresyntax(3) and\r\n        pcrepattern(3), but work only if PCRE is available in the system.\r\n\r\n        The fundamental building blocks are the regular expressions that match a single character.   Most  characters,\r\n        including  all  letters  and  digits,  are regular expressions that match themselves.  Any meta-character with\r\n        special meaning may be quoted by preceding it with a backslash.\r\n\r\n        The period . matches any single character.  It is unspecified whether it matches an encoding error.\r\n\r\n    Character Classes and Bracket Expressions\r\n        A bracket expression is a list of characters enclosed by [ and ].  It matches any  single  character  in  that\r\n        list.   If the first character of the list is the caret ^ then it matches any character not in the list; it is\r\n        unspecified whether it matches an encoding error.  For example, the regular  expression  [0123456789]  matches\r\n        any single digit.\r\n\r\n        Within  a bracket expression, a range expression consists of two characters separated by a hyphen.  It matches\r\n        any single character that sorts between the two characters, inclusive, using the locale's  collating  sequence\r\n        and  character  set.   For example, in the default C locale, [a-d] is equivalent to [abcd].  Many locales sort\r\n        characters in dictionary order, and in these locales [a-d] is typically not equivalent to [abcd]; it might  be\r\n        equivalent  to  [aBbCcDd],  for example.  To obtain the traditional interpretation of bracket expressions, you\r\n        can use the C locale by setting the LC_ALL environment variable to the value C.\r\n\r\n        Finally, certain named classes of characters are predefined within bracket  expressions,  as  follows.   Their\r\n        names  are  self  explanatory,  and they are [:alnum:], [:alpha:], [:blank:], [:cntrl:], [:digit:], [:graph:],\r\n        [:lower:], [:print:], [:punct:], [:space:], [:upper:], and [:xdigit:].  For  example,  [[:alnum:]]  means  the\r\n        character  class  of  numbers  and  letters  in  the  current locale.  In the C locale and ASCII character set\r\n        encoding, this is the same as [0-9A-Za-z].  (Note that the brackets in these  class  names  are  part  of  the\r\n        symbolic  names,  and  must  be included in addition to the brackets delimiting the bracket expression.)  Most\r\n        meta-characters lose their special meaning inside bracket expressions.  To include a literal ] place it  first\r\n        in  the list.  Similarly, to include a literal ^ place it anywhere but first.  Finally, to include a literal -\r\n        place it last.\r\n\r\n    Anchoring\r\n        The caret ^ and the dollar sign $ are  meta-characters  that  respectively  match  the  empty  string  at  the\r\n        beginning and end of a line.\r\n\r\n    The Backslash Character and Special Expressions\r\n        The  symbols  \\< and \\> respectively match the empty string at the beginning and end of a word.  The symbol \\b\r\n        matches the empty string at the edge of a word, and \\B matches the empty string provided it's not at the  edge\r\n        of a word.  The symbol \\w is a synonym for [_[:alnum:]] and \\W is a synonym for [^_[:alnum:]].\r\n\r\n    Repetition\r\n        A regular expression may be followed by one of several repetition operators:\r\n        ?      The preceding item is optional and matched at most once.\r\n        *      The preceding item will be matched zero or more times.\r\n        +      The preceding item will be matched one or more times.\r\n        {n}    The preceding item is matched exactly n times.\r\n        {n,}   The preceding item is matched n or more times.\r\n        {,m}   The preceding item is matched at most m times.  This is a GNU extension.\r\n        {n,m}  The preceding item is matched at least n times, but not more than m times.\r\n\r\n    Concatenation\r\n        Two  regular  expressions  may  be concatenated; the resulting regular expression matches any string formed by\r\n        concatenating two substrings that respectively match the concatenated expressions.\r\n\r\n    Alternation\r\n        Two regular expressions may be joined by the infix operator |; the resulting regular  expression  matches  any\r\n        string matching either alternate expression.\r\n\r\n    Precedence\r\n        Repetition  takes  precedence  over  concatenation,  which in turn takes precedence over alternation.  A whole\r\n        expression may be enclosed in parentheses to override these precedence rules and form a subexpression.\r\n\r\n    Back-references and Subexpressions\r\n        The back-reference \\n, where n is a single  digit,  matches  the  substring  previously  matched  by  the  nth\r\n        parenthesized subexpression of the regular expression.\r\n\r\n    Basic vs Extended Regular Expressions\r\n        In  basic regular expressions the meta-characters ?, +, {, |, (, and ) lose their special meaning; instead use\r\n        the backslashed versions \\?, \\+, \\{, \\|, \\(, and \\).\r\n\r\n    EXIT STATUS\r\n        Normally the exit status is 0 if a line is selected, 1 if no lines were selected, and 2 if an error  occurred.\r\n        However,  if  the  -q  or  --quiet or --silent is used and a line is selected, the exit status is 0 even if an\r\n        error occurred.\r\n\r\n    ENVIRONMENT\r\n        The behavior of grep is affected by the following environment variables.\r\n\r\n        The locale for category LC_foo is specified by examining the three environment variables LC_ALL, LC_foo, LANG,\r\n        in  that order.  The first of these variables that is set specifies the locale.  For example, if LC_ALL is not\r\n        set, but LC_MESSAGES is set to pt_BR, then the  Brazilian  Portuguese  locale  is  used  for  the  LC_MESSAGES\r\n        category.   The  C locale is used if none of these environment variables are set, if the locale catalog is not\r\n        installed, or if grep was not compiled with national language support (NLS).   The  shell  command  locale  -a\r\n        lists locales that are currently available.\r\n\r\n        GREP_COLOR\r\n                This  variable  specifies  the  color  used to highlight matched (non-empty) text.  It is deprecated in\r\n                favor of GREP_COLORS, but still supported.  The  mt,  ms,  and  mc  capabilities  of  GREP_COLORS  have\r\n                priority  over  it.  It can only specify the color used to highlight the matching non-empty text in any\r\n                matching line (a selected line when the -v command-line option is omitted, or a context line when -v is\r\n                specified).   The  default  is  01;31, which means a bold red foreground text on the terminal's default\r\n                background.\r\n\r\n        GREP_COLORS\r\n                Specifies the colors and other attributes used to highlight various parts of the output.  Its value  is\r\n                a        colon-separated        list        of        capabilities        that        defaults       to\r\n                ms=01;31:mc=01;31:sl=:cx=:fn=35:ln=32:bn=32:se=36 with the  rv  and  ne  boolean  capabilities  omitted\r\n                (i.e., false).  Supported capabilities are as follows.\r\n\r\n                sl=    SGR  substring for whole selected lines (i.e., matching lines when the -v command-line option is\r\n                        omitted, or non-matching lines when -v is specified).  If however the boolean rv capability  and\r\n                        the  -v  command-line  option  are both specified, it applies to context matching lines instead.\r\n                        The default is empty (i.e., the terminal's default color pair).\r\n\r\n                cx=    SGR substring for whole context lines (i.e., non-matching lines when the -v command-line  option\r\n                        is  omitted,  or matching lines when -v is specified).  If however the boolean rv capability and\r\n                        the -v command-line option are  both  specified,  it  applies  to  selected  non-matching  lines\r\n                        instead.  The default is empty (i.e., the terminal's default color pair).\r\n\r\n                rv     Boolean  value  that  reverses  (swaps) the meanings of the sl= and cx= capabilities when the -v\r\n                        command-line option is specified.  The default is false (i.e., the capability is omitted).\r\n\r\n                mt=01;31\r\n                        SGR substring for matching non-empty text in any matching line (i.e., a selected line  when  the\r\n                        -v  command-line  option  is  omitted, or a context line when -v is specified).  Setting this is\r\n                        equivalent to setting both ms= and mc= at once to the same value.  The default  is  a  bold  red\r\n                        text foreground over the current line background.\r\n\r\n                ms=01;31\r\n                        SGR  substring  for  matching non-empty text in a selected line.  (This is only used when the -v\r\n                        command-line option is omitted.)  The effect of the sl= (or cx= if rv) capability remains active\r\n                        when this kicks in.  The default is a bold red text foreground over the current line background.\r\n\r\n                mc=01;31\r\n                        SGR  substring  for  matching  non-empty text in a context line.  (This is only used when the -v\r\n                        command-line option is specified.)  The effect of the cx= (or  sl=  if  rv)  capability  remains\r\n                        active  when  this  kicks  in.   The default is a bold red text foreground over the current line\r\n                        background.\r\n\r\n                fn=35  SGR substring for file names prefixing  any  content  line.   The  default  is  a  magenta  text\r\n                        foreground over the terminal's default background.\r\n\r\n                ln=32  SGR  substring  for  line  numbers  prefixing  any  content  line.   The default is a green text\r\n                        foreground over the terminal's default background.\r\n\r\n                bn=32  SGR substring for byte offsets prefixing  any  content  line.   The  default  is  a  green  text\r\n                        foreground over the terminal's default background.\r\n\r\n                se=36  SGR substring for separators that are inserted between selected line fields (:), between context\r\n                        line fields, (-), and between groups of adjacent lines when nonzero context is  specified  (--).\r\n                        The default is a cyan text foreground over the terminal's default background.\r\n\r\n                ne     Boolean  value  that  prevents  clearing  to  the  end of line using Erase in Line (EL) to Right\r\n                        (\\33[K) each time a colorized item ends.  This is  needed  on  terminals  on  which  EL  is  not\r\n                        supported.   It  is  otherwise  useful on terminals for which the back_color_erase (bce) boolean\r\n                        terminfo capability does not  apply,  when  the  chosen  highlight  colors  do  not  affect  the\r\n                        background,  or when EL is too slow or causes too much flicker.  The default is false (i.e., the\r\n                        capability is omitted).\r\n\r\n                Note that boolean capabilities have no =... part.  They are omitted (i.e., false) by default and become\r\n                true when specified.\r\n\r\n                See  the  Select Graphic Rendition (SGR) section in the documentation of the text terminal that is used\r\n                for permitted values and their meaning as character attributes.  These substring values are integers in\r\n                decimal  representation  and  can  be  concatenated with semicolons.  grep takes care of assembling the\r\n                result into a complete SGR sequence (\\33[...m).  Common values to concatenate include 1 for bold, 4 for\r\n                underline, 5 for blink, 7 for inverse, 39 for default foreground color, 30 to 37 for foreground colors,\r\n                90 to 97 for 16-color mode foreground colors, 38;5;0 to  38;5;255  for  88-color  and  256-color  modes\r\n                foreground  colors,  49  for  default  background color, 40 to 47 for background colors, 100 to 107 for\r\n                16-color mode background colors, and 48;5;0 to 48;5;255 for 88-color  and  256-color  modes  background\r\n                colors.\r\n\r\n        LC_ALL, LC_COLLATE, LANG\r\n                These variables specify the locale for the LC_COLLATE category, which determines the collating sequence\r\n                used to interpret range expressions like [a-z].\r\n\r\n        LC_ALL, LC_CTYPE, LANG\r\n                These variables specify the locale for the LC_CTYPE category, which determines the type of  characters,\r\n                e.g.,  which characters are whitespace.  This category also determines the character encoding, that is,\r\n                whether text is encoded in UTF-8, ASCII, or some other  encoding.   In  the  C  or  POSIX  locale,  all\r\n                characters are encoded as a single byte and every byte is a valid character.\r\n\r\n        LC_ALL, LC_MESSAGES, LANG\r\n                These  variables  specify  the  locale for the LC_MESSAGES category, which determines the language that\r\n                grep uses for messages.  The default C locale uses American English messages.\r\n\r\n        POSIXLY_CORRECT\r\n                If set, grep behaves as POSIX requires; otherwise, grep behaves more like other  GNU  programs.   POSIX\r\n                requires  that  options  that follow file names must be treated as file names; by default, such options\r\n                are permuted to the front of the operand list and are treated as options.  Also,  POSIX  requires  that\r\n                unrecognized  options  be  diagnosed  as  “illegal”,  but since they are not really against the law the\r\n                default is to diagnose them as “invalid”.  POSIXLY_CORRECT also disables  _N_GNU_nonoption_argv_flags_,\r\n                described below.\r\n\r\n        _N_GNU_nonoption_argv_flags_\r\n                (Here N is grep's numeric process ID.)  If the ith character of this environment variable's value is 1,\r\n                do not consider the ith operand of grep to be an option, even if it appears to be one.  A shell can put\r\n                this variable in the environment for each command it runs, specifying which operands are the results of\r\n                file name wildcard expansion and therefore  should  not  be  treated  as  options.   This  behavior  is\r\n                available only with the GNU C library, and only when POSIXLY_CORRECT is not set.\r\n\r\n    NOTES\r\n        This man page is maintained only fitfully; the full documentation is often more up-to-date.\r\n\r\n    COPYRIGHT\r\n        Copyright 1998-2000, 2002, 2005-2020 Free Software Foundation, Inc.\r\n\r\n        This  is  free  software;  see  the  source  for  copying  conditions.   There  is  NO  warranty; not even for\r\n        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\r\n\r\n    BUGS\r\n    Reporting Bugs\r\n        Email   bug   reports   to   the    bug-reporting    address    ⟨bug-grep@gnu.org⟩.     An    email    archive\r\n        ⟨https://lists.gnu.org/mailman/listinfo/bug-grep⟩            and            a            bug           tracker\r\n        ⟨https://debbugs.gnu.org/cgi/pkgreport.cgi?package=grep⟩ are available.\r\n\r\n    Known Bugs\r\n        Large repetition counts in the {n,m} construct may cause grep to use lots of  memory.   In  addition,  certain\r\n        other obscure regular expressions require exponential time and space, and may cause grep to run out of memory.\r\n\r\n        Back-references are very slow, and may require exponential time.\r\n\r\n    EXAMPLE\r\n        The  following example outputs the location and contents of any line containing “f” and ending in “.c”, within\r\n        all files in the current directory whose names contain “g” and end in “.h”.  The -n option outputs  line  num‐\r\n        bers,  the -- argument treats expansions of “*g*.h” starting with “-” as file names not options, and the empty\r\n        file /dev/null causes file names to be output even if only one file name happens to be of the form “*g*.h”.\r\n\r\n            $ grep -n -- 'f.*\\.c$' *g*.h /dev/null\r\n            argmatch.h:1:/* definitions and prototypes for argmatch.c\r\n\r\n        The only line that matches is line 1 of argmatch.h.  Note that the regular expression syntax used in the  pat‐\r\n        tern differs from the globbing syntax that the shell uses to match file names.\r\n\r\n    SEE ALSO\r\n    Regular Manual Pages\r\n        awk(1),  cmp(1),  diff(1),  find(1),  perl(1),  sed(1),  sort(1),  xargs(1),  read(2), pcre(3), pcresyntax(3),\r\n        pcrepattern(3), terminfo(5), glob(7), regex(7).\r\n\r\n    Full Documentation\r\n        A complete manual ⟨https://www.gnu.org/software/grep/manual/⟩ is available.  If the info and grep programs are\r\n        properly installed at your site, the command\r\n\r\n                info grep\r\n\r\n        should give you access to the complete manual.\r\n\r\n    GNU grep 3.6                                          2019-12-29                                              GREP(1)\r\n\r\n## What is REGEX\r\n\r\n**Regex**, or **Reg**ular **Ex**pression, is a way of writing search queries that look for specific phrases. A regex expression is a form of pattern matching. For the purpose of this article we will skip the regex tutorial. \r\n\r\nHere are some basics for a recap.\r\n\r\n\r\n### Anchors\r\nThese are expressions that signify a position as a condition. Using one of these means that for there to be a match then you must find the particular phrase in the required position. For example, when we use `^` we are signifying that the phrase after it must be at the beginning of any match. Say `^c` would be true for `chris` but would be false for `back`. In the first case we have the word `chris` which begins with a c. This provides a match and thus is true for the regex of `^c`. Since `back` only contains a c at the end it does not satisfy the case of `^c`. \r\n\r\n| Expression    | Description      | Example                                      |\r\n| ---           | ---              | ---                                          |\r\n| ^[exp]        | Start            | ^a  - \"Hola <u>**a**</u>migo\"                |\r\n| \\A[exp]       | Start            | \\Aa - \"Hola <u>**a**</u>migo\"                |\r\n| [exp]$        | End              | d$  - \"Hello Worl<u>**d**</u>\"               |\r\n| [exp]\\Z       | End              | d\\Z - \"Hello Worl<u>**d**</u>\"               |\r\n| \\b[exp]\\b     | Word Boundary    | \\bme\\b - \"<u>**me**</u> not some\"          |\r\n| \\B[exp]\\B     | Not Word Boundary| \\Bme\\B - \"Ho<u>**me**</u>r not me or some\" |\r\n\r\n*Note: The use of [exp] is designed to represent a standalone expression. This should not be confused wtih the actual brackets notation.*\r\n\r\nLet's look at those work boudaries. They are a bit strange but useful. If a word is a group of letters then a word boundary is the edge of that word. In other words, a letter next to a space would be a word boundary. `/b` is a word boundary. The side of the expression you apply /b to is the side of the expression that you want a boundary on. If both side have a boundary then you can safely say you are looking for an exact word match. This looks like `/bword\\b`. If we want a phrase that ends with an expression then we can use `[exp]\\b`.\r\n\r\nTODO: add some examples of these being demonstrated in the console. Python or JS regex.\r\n\r\n";
				}
				function compiledContent() {
					return html;
				}
				function getHeadings() {
					return [{"depth":2,"slug":"what-is-grep","text":"What is GREP"},{"depth":2,"slug":"what-is-regex","text":"What is REGEX"},{"depth":3,"slug":"anchors","text":"Anchors"}];
				}

				const Content = createComponent((result, _props, slots) => {
					const { layout, ...content } = frontmatter;
					content.file = file;
					content.url = url;

					return renderTemplate`${maybeRenderHead()}${unescapeHTML(html)}`;
				});

export { Content, compiledContent, Content as default, file, frontmatter, getHeadings, rawContent, url };
