<!DOCTYPE html>
<html lang="en" class="astro-BVZIHDZO">
	<head>
		<!-- Global Metadata --><meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<link rel="icon" type="image/svg+xml" href="/favicon.svg">
<meta name="generator" content="Astro v2.0.16">

<!-- Primary Meta Tags -->
<title>Grep</title>
<meta name="title" content="Grep">
<meta name="description" content="Grep reference">

<!-- Open Graph / Facebook -->
<meta property="og:type" content="website">
<meta property="og:url" content="https://brunscii.github.io/astro-blog-site/blog/linux_commands/grep/">
<meta property="og:title" content="Grep">
<meta property="og:description" content="Grep reference">
<meta property="og:image" content="https://brunscii.github.io/placeholder-social.jpg">

		
		
	<link rel="stylesheet" href="/astro-blog-site/_astro/_...slug_.d7ec7cc9.css" />
<link rel="stylesheet" href="/astro-blog-site/_astro/HeaderLink.astro_astro_type_style_index_0_lang.c3840210.css" />
<link rel="stylesheet" href="/astro-blog-site/_astro/_...slug_.3f4867e1.css" /></head>

	<body class="astro-BVZIHDZO">
		<header class="astro-3EF6KSR2">
	<h1 class="astro-3EF6KSR2">
		Chris C&#39;s Blog
	</h1>
	<nav class="astro-3EF6KSR2">
		<a href="{BASE}/" class="astro-3EF6KSR2 astro-EIMMU3LG">
	Home
</a>
		<a href="{BASE}/blog" class="astro-3EF6KSR2 astro-EIMMU3LG">
	Blog
</a>
		<a href="{BASE}/about" class="astro-3EF6KSR2 astro-EIMMU3LG">
	About
</a>
		<a href="https://christopherjcarlin.com" class="astro-3EF6KSR2 astro-EIMMU3LG" target="_blank">
	Portfolio
</a>
		<a href="https://github.com/brunscii" class="astro-3EF6KSR2 astro-EIMMU3LG" target="_blank">
	GitHub
</a>
	</nav>
</header>
		<main class="astro-BVZIHDZO">
			<article class="astro-BVZIHDZO">
				
				
				<h1 class="title astro-BVZIHDZO">Grep</h1>

				<!-- Modified incase there is no date given --><time datetime="2023-01-07T05:00:00.000Z">
	Jan 7, 2023
</time>
				<div class="last-updated-on astro-BVZIHDZO">
							Last updated on <!-- Modified incase there is no date given --><time datetime="2023-03-02T05:00:00.000Z">
	Mar 2, 2023
</time>
						</div>
				<hr class="astro-BVZIHDZO">
				<!-- # GREP -->
<h2 id="what-is-grep">What is GREP</h2>
<p><strong>GREP</strong> stands for <strong>G</strong>lobal <strong>R</strong>egular <strong>E</strong>xpresion <strong>P</strong>rint. While the name does sound like grep would actually
print out regular expressions, or regex for short, but it actually prints out matches to those regular expressions.</p>
<p>Grep a powerful yet rarely understood tool that is used to match patterns.</p>
<p>According to grep’s built-in <code>--help</code> function, this is the structure of grep.</p>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9">Usage: grep [OPTION]... PATTERNS [FILE]...</span></span>
<span class="line"><span style="color: #c9d1d9">Search for PATTERNS in each FILE.</span></span>
<span class="line"><span style="color: #c9d1d9">Example: grep -i 'hello world' menu.h main.c</span></span>
<span class="line"><span style="color: #c9d1d9">PATTERNS can contain multiple patterns separated by newlines.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">Pattern selection and interpretation:</span></span>
<span class="line"><span style="color: #c9d1d9">-E, --extended-regexp     PATTERNS are extended regular expressions</span></span>
<span class="line"><span style="color: #c9d1d9">-F, --fixed-strings       PATTERNS are strings</span></span>
<span class="line"><span style="color: #c9d1d9">-G, --basic-regexp        PATTERNS are basic regular expressions</span></span>
<span class="line"><span style="color: #c9d1d9">-P, --perl-regexp         PATTERNS are Perl regular expressions</span></span>
<span class="line"><span style="color: #c9d1d9">-e, --regexp=PATTERNS     use PATTERNS for matching</span></span>
<span class="line"><span style="color: #c9d1d9">-f, --file=FILE           take PATTERNS from FILE</span></span>
<span class="line"><span style="color: #c9d1d9">-i, --ignore-case         ignore case distinctions in patterns and data</span></span>
<span class="line"><span style="color: #c9d1d9">    --no-ignore-case      do not ignore case distinctions (default)</span></span>
<span class="line"><span style="color: #c9d1d9">-w, --word-regexp         match only whole words</span></span>
<span class="line"><span style="color: #c9d1d9">-x, --line-regexp         match only whole lines</span></span>
<span class="line"><span style="color: #c9d1d9">-z, --null-data           a data line ends in 0 byte, not newline</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">Miscellaneous:</span></span>
<span class="line"><span style="color: #c9d1d9">-s, --no-messages         suppress error messages</span></span>
<span class="line"><span style="color: #c9d1d9">-v, --invert-match        select non-matching lines</span></span>
<span class="line"><span style="color: #c9d1d9">-V, --version             display version information and exit</span></span>
<span class="line"><span style="color: #c9d1d9">    --help                display this help text and exit</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">Output control:</span></span>
<span class="line"><span style="color: #c9d1d9">-m, --max-count=NUM       stop after NUM selected lines</span></span>
<span class="line"><span style="color: #c9d1d9">-b, --byte-offset         print the byte offset with output lines</span></span>
<span class="line"><span style="color: #c9d1d9">-n, --line-number         print line number with output lines</span></span>
<span class="line"><span style="color: #c9d1d9">    --line-buffered       flush output on every line</span></span>
<span class="line"><span style="color: #c9d1d9">-H, --with-filename       print file name with output lines</span></span>
<span class="line"><span style="color: #c9d1d9">-h, --no-filename         suppress the file name prefix on output</span></span>
<span class="line"><span style="color: #c9d1d9">    --label=LABEL         use LABEL as the standard input file name prefix</span></span>
<span class="line"><span style="color: #c9d1d9">-o, --only-matching       show only nonempty parts of lines that match</span></span>
<span class="line"><span style="color: #c9d1d9">-q, --quiet, --silent     suppress all normal output</span></span>
<span class="line"><span style="color: #c9d1d9">    --binary-files=TYPE   assume that binary files are TYPE;</span></span>
<span class="line"><span style="color: #c9d1d9">                            TYPE is 'binary', 'text', or 'without-match'</span></span>
<span class="line"><span style="color: #c9d1d9">-a, --text                equivalent to --binary-files=text</span></span>
<span class="line"><span style="color: #c9d1d9">-I                        equivalent to --binary-files=without-match</span></span>
<span class="line"><span style="color: #c9d1d9">-d, --directories=ACTION  how to handle directories;</span></span>
<span class="line"><span style="color: #c9d1d9">                            ACTION is 'read', 'recurse', or 'skip'</span></span>
<span class="line"><span style="color: #c9d1d9">-D, --devices=ACTION      how to handle devices, FIFOs and sockets;</span></span>
<span class="line"><span style="color: #c9d1d9">                            ACTION is 'read' or 'skip'</span></span>
<span class="line"><span style="color: #c9d1d9">-r, --recursive           like --directories=recurse</span></span>
<span class="line"><span style="color: #c9d1d9">-R, --dereference-recursive  likewise, but follow all symlinks</span></span>
<span class="line"><span style="color: #c9d1d9">    --include=GLOB        search only files that match GLOB (a file pattern)</span></span>
<span class="line"><span style="color: #c9d1d9">    --exclude=GLOB        skip files that match GLOB</span></span>
<span class="line"><span style="color: #c9d1d9">    --exclude-from=FILE   skip files that match any file pattern from FILE</span></span>
<span class="line"><span style="color: #c9d1d9">    --exclude-dir=GLOB    skip directories that match GLOB</span></span>
<span class="line"><span style="color: #c9d1d9">-L, --files-without-match  print only names of FILEs with no selected lines</span></span>
<span class="line"><span style="color: #c9d1d9">-l, --files-with-matches  print only names of FILEs with selected lines</span></span>
<span class="line"><span style="color: #c9d1d9">-c, --count               print only a count of selected lines per FILE</span></span>
<span class="line"><span style="color: #c9d1d9">-T, --initial-tab         make tabs line up (if needed)</span></span>
<span class="line"><span style="color: #c9d1d9">-Z, --null                print 0 byte after FILE name</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">Context control:</span></span>
<span class="line"><span style="color: #c9d1d9">-B, --before-context=NUM  print NUM lines of leading context</span></span>
<span class="line"><span style="color: #c9d1d9">-A, --after-context=NUM   print NUM lines of trailing context</span></span>
<span class="line"><span style="color: #c9d1d9">-C, --context=NUM         print NUM lines of output context</span></span>
<span class="line"><span style="color: #c9d1d9">-NUM                      same as --context=NUM</span></span>
<span class="line"><span style="color: #c9d1d9">    --color[=WHEN],</span></span>
<span class="line"><span style="color: #c9d1d9">    --colour[=WHEN]       use markers to highlight the matching strings;</span></span>
<span class="line"><span style="color: #c9d1d9">                            WHEN is 'always', 'never', or 'auto'</span></span>
<span class="line"><span style="color: #c9d1d9">-U, --binary              do not strip CR characters at EOL (MSDOS/Windows)</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">When FILE is '-', read standard input.  With no FILE, read '.' if</span></span>
<span class="line"><span style="color: #c9d1d9">recursive, '-' otherwise.  With fewer than two FILEs, assume -h.</span></span>
<span class="line"><span style="color: #c9d1d9">Exit status is 0 if any line is selected, 1 otherwise;</span></span>
<span class="line"><span style="color: #c9d1d9">if any error occurs and -q is not given, the exit status is 2.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">Report bugs to: bug-grep@gnu.org</span></span>
<span class="line"><span style="color: #c9d1d9">GNU grep home page: &#x3C;http://www.gnu.org/software/grep/></span></span>
<span class="line"><span style="color: #c9d1d9">General help using GNU software: &#x3C;https://www.gnu.org/gethelp/></span></span></code></pre>
<p>So what if you are a man page user? Well it might look more like this:</p>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9">GREP(1)                                             User Commands                                             GREP(1)</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">NAME</span></span>
<span class="line"><span style="color: #c9d1d9">    grep, egrep, fgrep, rgrep - print lines that match patterns</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">SYNOPSIS</span></span>
<span class="line"><span style="color: #c9d1d9">    grep [OPTION...] PATTERNS [FILE...]</span></span>
<span class="line"><span style="color: #c9d1d9">    grep [OPTION...] -e PATTERNS ... [FILE...]</span></span>
<span class="line"><span style="color: #c9d1d9">    grep [OPTION...] -f PATTERN_FILE ... [FILE...]</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">DESCRIPTION</span></span>
<span class="line"><span style="color: #c9d1d9">    grep  searches  for  PATTERNS in each FILE.  PATTERNS is one or more patterns separated by newline characters,</span></span>
<span class="line"><span style="color: #c9d1d9">    and grep prints each line that matches a pattern.  Typically PATTERNS should be quoted when grep is used in  a</span></span>
<span class="line"><span style="color: #c9d1d9">    shell command.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">    A  FILE  of  “-”  stands  for  standard  input.   If  no FILE is given, recursive searches examine the working</span></span>
<span class="line"><span style="color: #c9d1d9">    directory, and nonrecursive searches read standard input.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">    In addition, the variant programs egrep, fgrep and rgrep are  the  same  as  grep -E,  grep -F,  and  grep -r,</span></span>
<span class="line"><span style="color: #c9d1d9">    respectively.  These variants are deprecated, but are provided for backward compatibility.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">OPTIONS</span></span>
<span class="line"><span style="color: #c9d1d9">Generic Program Information</span></span>
<span class="line"><span style="color: #c9d1d9">    --help Output a usage message and exit.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">    -V, --version</span></span>
<span class="line"><span style="color: #c9d1d9">            Output the version number of grep and exit.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">Pattern Syntax</span></span>
<span class="line"><span style="color: #c9d1d9">    -E, --extended-regexp</span></span>
<span class="line"><span style="color: #c9d1d9">            Interpret PATTERNS as extended regular expressions (EREs, see below).</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">    -F, --fixed-strings</span></span>
<span class="line"><span style="color: #c9d1d9">            Interpret PATTERNS as fixed strings, not regular expressions.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">    -G, --basic-regexp</span></span>
<span class="line"><span style="color: #c9d1d9">            Interpret PATTERNS as basic regular expressions (BREs, see below).  This is the default.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">    -P, --perl-regexp</span></span>
<span class="line"><span style="color: #c9d1d9">            Interpret  PATTERNS  as  Perl-compatible regular expressions (PCREs).  This option is experimental when</span></span>
<span class="line"><span style="color: #c9d1d9">            combined with the -z (--null-data) option, and grep -P may warn of unimplemented features.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">Matching Control</span></span>
<span class="line"><span style="color: #c9d1d9">    -e PATTERNS, --regexp=PATTERNS</span></span>
<span class="line"><span style="color: #c9d1d9">            Use PATTERNS as the patterns.  If this option is used  multiple  times  or  is  combined  with  the  -f</span></span>
<span class="line"><span style="color: #c9d1d9">            (--file) option, search for all patterns given.  This option can be used to protect a pattern beginning</span></span>
<span class="line"><span style="color: #c9d1d9">            with “-”.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">    -f FILE, --file=FILE</span></span>
<span class="line"><span style="color: #c9d1d9">            Obtain patterns from FILE, one per line.  If this option is used multiple times or is combined with the</span></span>
<span class="line"><span style="color: #c9d1d9">            -e  (--regexp)  option,  search  for  all  patterns  given.  The empty file contains zero patterns, and</span></span>
<span class="line"><span style="color: #c9d1d9">            therefore matches nothing.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">    -i, --ignore-case</span></span>
<span class="line"><span style="color: #c9d1d9">            Ignore case distinctions in patterns and input data, so that characters that differ only in case  match</span></span>
<span class="line"><span style="color: #c9d1d9">            each other.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">    --no-ignore-case</span></span>
<span class="line"><span style="color: #c9d1d9">            Do  not  ignore  case  distinctions  in  patterns and input data.  This is the default.  This option is</span></span>
<span class="line"><span style="color: #c9d1d9">            useful for passing to shell scripts that already use -i, to cancel its effects because the two  options</span></span>
<span class="line"><span style="color: #c9d1d9">            override each other.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">    -v, --invert-match</span></span>
<span class="line"><span style="color: #c9d1d9">            Invert the sense of matching, to select non-matching lines.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">    -w, --word-regexp</span></span>
<span class="line"><span style="color: #c9d1d9">            Select  only  those  lines  containing  matches  that  form whole words.  The test is that the matching</span></span>
<span class="line"><span style="color: #c9d1d9">            substring must either be at the beginning of the line, or preceded by a non-word constituent character.</span></span>
<span class="line"><span style="color: #c9d1d9">            Similarly,  it  must  be either at the end of the line or followed by a non-word constituent character.</span></span>
<span class="line"><span style="color: #c9d1d9">            Word-constituent characters are letters, digits, and the underscore.  This option has no effect  if  -x</span></span>
<span class="line"><span style="color: #c9d1d9">            is also specified.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">    -x, --line-regexp</span></span>
<span class="line"><span style="color: #c9d1d9">            Select only those matches that exactly match the whole line.  For a regular expression pattern, this is</span></span>
<span class="line"><span style="color: #c9d1d9">            like parenthesizing the pattern and then surrounding it with ^ and $.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">    -y     Obsolete synonym for -i.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">General Output Control</span></span>
<span class="line"><span style="color: #c9d1d9">    -c, --count</span></span>
<span class="line"><span style="color: #c9d1d9">            Suppress normal output; instead print a count of matching lines for each  input  file.   With  the  -v,</span></span>
<span class="line"><span style="color: #c9d1d9">            --invert-match option (see below), count non-matching lines.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">    --color[=WHEN], --colour[=WHEN]</span></span>
<span class="line"><span style="color: #c9d1d9">            Surround the matched (non-empty) strings, matching lines, context lines, file names, line numbers, byte</span></span>
<span class="line"><span style="color: #c9d1d9">            offsets, and separators (for fields and groups of context lines) with escape sequences to display  them</span></span>
<span class="line"><span style="color: #c9d1d9">            in  color  on  the  terminal.   The  colors  are  defined by the environment variable GREP_COLORS.  The</span></span>
<span class="line"><span style="color: #c9d1d9">            deprecated environment variable GREP_COLOR is still supported, but its setting does not have  priority.</span></span>
<span class="line"><span style="color: #c9d1d9">            WHEN is never, always, or auto.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">    -L, --files-without-match</span></span>
<span class="line"><span style="color: #c9d1d9">            Suppress  normal  output; instead print the name of each input file from which no output would normally</span></span>
<span class="line"><span style="color: #c9d1d9">            have been printed.  The scanning will stop on the first match.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">    -l, --files-with-matches</span></span>
<span class="line"><span style="color: #c9d1d9">            Suppress normal output; instead print the name of each input file from which output would normally have</span></span>
<span class="line"><span style="color: #c9d1d9">            been printed.  The scanning will stop on the first match.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">    -m NUM, --max-count=NUM</span></span>
<span class="line"><span style="color: #c9d1d9">            Stop  reading a file after NUM matching lines.  If the input is standard input from a regular file, and</span></span>
<span class="line"><span style="color: #c9d1d9">            NUM matching lines are output, grep ensures that the standard input is positioned  to  just  after  the</span></span>
<span class="line"><span style="color: #c9d1d9">            last  matching line before exiting, regardless of the presence of trailing context lines.  This enables</span></span>
<span class="line"><span style="color: #c9d1d9">            a calling process to resume a search.  When grep  stops  after  NUM  matching  lines,  it  outputs  any</span></span>
<span class="line"><span style="color: #c9d1d9">            trailing  context  lines.   When  the  -c  or --count option is also used, grep does not output a count</span></span>
<span class="line"><span style="color: #c9d1d9">            greater than NUM.  When the -v or --invert-match option is also used, grep stops after  outputting  NUM</span></span>
<span class="line"><span style="color: #c9d1d9">            non-matching lines.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">    -o, --only-matching</span></span>
<span class="line"><span style="color: #c9d1d9">            Print  only  the matched (non-empty) parts of a matching line, with each such part on a separate output</span></span>
<span class="line"><span style="color: #c9d1d9">            line.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">    -q, --quiet, --silent</span></span>
<span class="line"><span style="color: #c9d1d9">            Quiet; do not write anything to standard output.  Exit immediately with zero status  if  any  match  is</span></span>
<span class="line"><span style="color: #c9d1d9">            found, even if an error was detected.  Also see the -s or --no-messages option.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">    -s, --no-messages</span></span>
<span class="line"><span style="color: #c9d1d9">            Suppress error messages about nonexistent or unreadable files.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">Output Line Prefix Control</span></span>
<span class="line"><span style="color: #c9d1d9">    -b, --byte-offset</span></span>
<span class="line"><span style="color: #c9d1d9">            Print   the   0-based  byte  offset  within  the  input  file  before  each  line  of  output.   If  -o</span></span>
<span class="line"><span style="color: #c9d1d9">            (--only-matching) is specified, print the offset of the matching part itself.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">    -H, --with-filename</span></span>
<span class="line"><span style="color: #c9d1d9">            Print the file name for each match.  This is the default when there is more than one file to search.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">    -h, --no-filename</span></span>
<span class="line"><span style="color: #c9d1d9">            Suppress the prefixing of file names on output.  This is the default when there is only  one  file  (or</span></span>
<span class="line"><span style="color: #c9d1d9">            only standard input) to search.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">    --label=LABEL</span></span>
<span class="line"><span style="color: #c9d1d9">            Display  input actually coming from standard input as input coming from file LABEL.  This can be useful</span></span>
<span class="line"><span style="color: #c9d1d9">            for commands that transform  a  file's  contents  before  searching,  e.g.,  gzip  -cd  foo.gz  |  grep</span></span>
<span class="line"><span style="color: #c9d1d9">            --label=foo -H 'some pattern'.  See also the -H option.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">    -n, --line-number</span></span>
<span class="line"><span style="color: #c9d1d9">            Prefix each line of output with the 1-based line number within its input file.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">    -T, --initial-tab</span></span>
<span class="line"><span style="color: #c9d1d9">            Make  sure that the first character of actual line content lies on a tab stop, so that the alignment of</span></span>
<span class="line"><span style="color: #c9d1d9">            tabs looks normal.  This is useful with options that prefix their output to the actual content:  -H,-n,</span></span>
<span class="line"><span style="color: #c9d1d9">            and  -b.   In order to improve the probability that lines from a single file will all start at the same</span></span>
<span class="line"><span style="color: #c9d1d9">            column, this also causes the line number and byte offset (if present) to be printed in a  minimum  size</span></span>
<span class="line"><span style="color: #c9d1d9">            field width.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">    -u, --unix-byte-offsets</span></span>
<span class="line"><span style="color: #c9d1d9">            Report  Unix-style  byte offsets.  This switch causes grep to report byte offsets as if the file were a</span></span>
<span class="line"><span style="color: #c9d1d9">            Unix-style text file, i.e., with CR characters stripped off.  This will produce  results  identical  to</span></span>
<span class="line"><span style="color: #c9d1d9">            running  grep  on  a  Unix machine.  This option has no effect unless -b option is also used; it has no</span></span>
<span class="line"><span style="color: #c9d1d9">            effect on platforms other than MS-DOS and MS-Windows.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">    -Z, --null</span></span>
<span class="line"><span style="color: #c9d1d9">            Output a zero byte (the ASCII NUL character) instead of the character  that  normally  follows  a  file</span></span>
<span class="line"><span style="color: #c9d1d9">            name.   For  example,  grep  -lZ outputs a zero byte after each file name instead of the usual newline.</span></span>
<span class="line"><span style="color: #c9d1d9">            This option makes the output unambiguous, even  in  the  presence  of  file  names  containing  unusual</span></span>
<span class="line"><span style="color: #c9d1d9">            characters  like  newlines.  This option can be used with commands like find -print0, perl -0, sort -z,</span></span>
<span class="line"><span style="color: #c9d1d9">            and xargs -0 to process arbitrary file names, even those that contain newline characters.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">Context Line Control</span></span>
<span class="line"><span style="color: #c9d1d9">    -A NUM, --after-context=NUM</span></span>
<span class="line"><span style="color: #c9d1d9">            Print NUM lines of trailing context after matching lines.  Places a line containing a  group  separator</span></span>
<span class="line"><span style="color: #c9d1d9">            (--)  between  contiguous groups of matches.  With the -o or --only-matching option, this has no effect</span></span>
<span class="line"><span style="color: #c9d1d9">            and a warning is given.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">    -B NUM, --before-context=NUM</span></span>
<span class="line"><span style="color: #c9d1d9">            Print NUM lines of leading context before matching lines.  Places a line containing a  group  separator</span></span>
<span class="line"><span style="color: #c9d1d9">            (--)  between  contiguous groups of matches.  With the -o or --only-matching option, this has no effect</span></span>
<span class="line"><span style="color: #c9d1d9">            and a warning is given.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">    -C NUM, -NUM, --context=NUM</span></span>
<span class="line"><span style="color: #c9d1d9">            Print NUM lines of output context.  Places a line containing a group separator (--) between  contiguous</span></span>
<span class="line"><span style="color: #c9d1d9">            groups of matches.  With the -o or --only-matching option, this has no effect and a warning is given.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">File and Directory Selection</span></span>
<span class="line"><span style="color: #c9d1d9">    -a, --text</span></span>
<span class="line"><span style="color: #c9d1d9">            Process a binary file as if it were text; this is equivalent to the --binary-files=text option.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">    --binary-files=TYPE</span></span>
<span class="line"><span style="color: #c9d1d9">            If  a  file's  data or metadata indicate that the file contains binary data, assume that the file is of</span></span>
<span class="line"><span style="color: #c9d1d9">            type TYPE.  Non-text bytes indicate binary data; these are either  output  bytes  that  are  improperly</span></span>
<span class="line"><span style="color: #c9d1d9">            encoded for the current locale, or null input bytes when the -z option is not given.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">            By  default, TYPE is binary, and grep suppresses output after null input binary data is discovered, and</span></span>
<span class="line"><span style="color: #c9d1d9">            suppresses output lines that contain improperly encoded data.  When some  output  is  suppressed,  grep</span></span>
<span class="line"><span style="color: #c9d1d9">            follows any output with a one-line message saying that a binary file matches.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">            If  TYPE  is  without-match, when grep discovers null input binary data it assumes that the rest of the</span></span>
<span class="line"><span style="color: #c9d1d9">            file does not match; this is equivalent to the -I option.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">            If TYPE is text, grep processes a binary file as if it were text; this is equivalent to the -a option.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">            When type is binary, grep may treat non-text bytes as line terminators  even  without  the  -z  option.</span></span>
<span class="line"><span style="color: #c9d1d9">            This  means choosing binary versus text can affect whether a pattern matches a file.  For example, when</span></span>
<span class="line"><span style="color: #c9d1d9">            type is binary the pattern q$ might match q immediately followed by a null byte, even  though  this  is</span></span>
<span class="line"><span style="color: #c9d1d9">            not  matched when type is text.  Conversely, when type is binary the pattern . (period) might not match</span></span>
<span class="line"><span style="color: #c9d1d9">            a null byte.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">            Warning: The -a option might output binary garbage, which can have nasty side effects if the output  is</span></span>
<span class="line"><span style="color: #c9d1d9">            a  terminal  and  if  the  terminal  driver interprets some of it as commands.  On the other hand, when</span></span>
<span class="line"><span style="color: #c9d1d9">            reading files whose text encodings are unknown, it can be helpful to use -a or to set LC_ALL='C' in the</span></span>
<span class="line"><span style="color: #c9d1d9">            environment, in order to find more matches even if the matches are unsafe for direct display.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">    -D ACTION, --devices=ACTION</span></span>
<span class="line"><span style="color: #c9d1d9">            If  an  input  file is a device, FIFO or socket, use ACTION to process it.  By default, ACTION is read,</span></span>
<span class="line"><span style="color: #c9d1d9">            which means that devices are read just as if they were ordinary files.  If ACTION is skip, devices  are</span></span>
<span class="line"><span style="color: #c9d1d9">            silently skipped.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">    -d ACTION, --directories=ACTION</span></span>
<span class="line"><span style="color: #c9d1d9">            If  an  input  file  is  a directory, use ACTION to process it.  By default, ACTION is read, i.e., read</span></span>
<span class="line"><span style="color: #c9d1d9">            directories just as if they were ordinary files.  If ACTION is skip,  silently  skip  directories.   If</span></span>
<span class="line"><span style="color: #c9d1d9">            ACTION  is  recurse, read all files under each directory, recursively, following symbolic links only if</span></span>
<span class="line"><span style="color: #c9d1d9">            they are on the command line.  This is equivalent to the -r option.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">    --exclude=GLOB</span></span>
<span class="line"><span style="color: #c9d1d9">            Skip any command-line file with a name suffix that matches the pattern GLOB, using wildcard matching; a</span></span>
<span class="line"><span style="color: #c9d1d9">            name  suffix  is  either  the  whole  name,  or  a trailing part that starts with a non-slash character</span></span>
<span class="line"><span style="color: #c9d1d9">            immediately after a slash (/) in the name.  When searching recursively, skip  any  subfile  whose  base</span></span>
<span class="line"><span style="color: #c9d1d9">            name  matches  GLOB; the base name is the part after the last slash.  A pattern can use *, ?, and [...]</span></span>
<span class="line"><span style="color: #c9d1d9">            as wildcards, and \ to quote a wildcard or backslash character literally.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">    --exclude-from=FILE</span></span>
<span class="line"><span style="color: #c9d1d9">            Skip files whose base name matches any of the file-name globs read from FILE (using  wildcard  matching</span></span>
<span class="line"><span style="color: #c9d1d9">            as described under --exclude).</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">    --exclude-dir=GLOB</span></span>
<span class="line"><span style="color: #c9d1d9">            Skip  any  command-line  directory  with  a  name suffix that matches the pattern GLOB.  When searching</span></span>
<span class="line"><span style="color: #c9d1d9">            recursively, skip any subdirectory whose base name matches GLOB.  Ignore any redundant trailing slashes</span></span>
<span class="line"><span style="color: #c9d1d9">            in GLOB.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">    -I     Process  a  binary  file  as  if  it  did  not  contain  matching  data;  this  is  equivalent  to  the</span></span>
<span class="line"><span style="color: #c9d1d9">            --binary-files=without-match option.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">    --include=GLOB</span></span>
<span class="line"><span style="color: #c9d1d9">            Search only files whose base name matches GLOB (using wildcard matching as described under  --exclude).</span></span>
<span class="line"><span style="color: #c9d1d9">            If  contradictory  --include  and  --exclude  options  are  given,  the  last matching one wins.  If no</span></span>
<span class="line"><span style="color: #c9d1d9">            --include or --exclude options match, a file is included unless the first such option is --include.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">    -r, --recursive</span></span>
<span class="line"><span style="color: #c9d1d9">            Read all files under each directory, recursively, following symbolic links only  if  they  are  on  the</span></span>
<span class="line"><span style="color: #c9d1d9">            command  line.   Note  that  if no file operand is given, grep searches the working directory.  This is</span></span>
<span class="line"><span style="color: #c9d1d9">            equivalent to the -d recurse option.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">    -R, --dereference-recursive</span></span>
<span class="line"><span style="color: #c9d1d9">            Read all files under each directory, recursively.  Follow all symbolic links, unlike -r.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">Other Options</span></span>
<span class="line"><span style="color: #c9d1d9">    --line-buffered</span></span>
<span class="line"><span style="color: #c9d1d9">            Use line buffering on output.  This can cause a performance penalty.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">    -U, --binary</span></span>
<span class="line"><span style="color: #c9d1d9">            Treat the file(s) as binary.  By default, under MS-DOS and MS-Windows, grep guesses whether a  file  is</span></span>
<span class="line"><span style="color: #c9d1d9">            text or binary as described for the --binary-files option.  If grep decides the file is a text file, it</span></span>
<span class="line"><span style="color: #c9d1d9">            strips the CR characters from the original file contents (to make regular expressions with ^ and $ work</span></span>
<span class="line"><span style="color: #c9d1d9">            correctly).   Specifying  -U  overrules  this guesswork, causing all files to be read and passed to the</span></span>
<span class="line"><span style="color: #c9d1d9">            matching mechanism verbatim; if the file is a text file with CR/LF pairs at the end of each line,  this</span></span>
<span class="line"><span style="color: #c9d1d9">            will  cause some regular expressions to fail.  This option has no effect on platforms other than MS-DOS</span></span>
<span class="line"><span style="color: #c9d1d9">            and MS-Windows.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">    -z, --null-data</span></span>
<span class="line"><span style="color: #c9d1d9">            Treat input and output data as sequences of lines, each terminated  by  a  zero  byte  (the  ASCII  NUL</span></span>
<span class="line"><span style="color: #c9d1d9">            character)  instead  of a newline.  Like the -Z or --null option, this option can be used with commands</span></span>
<span class="line"><span style="color: #c9d1d9">            like sort -z to process arbitrary file names.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">REGULAR EXPRESSIONS</span></span>
<span class="line"><span style="color: #c9d1d9">    A regular expression is a pattern that describes a  set  of  strings.   Regular  expressions  are  constructed</span></span>
<span class="line"><span style="color: #c9d1d9">    analogously to arithmetic expressions, by using various operators to combine smaller expressions.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">    grep  understands  three  different versions of regular expression syntax: “basic” (BRE), “extended” (ERE) and</span></span>
<span class="line"><span style="color: #c9d1d9">    “perl” (PCRE).  In GNU grep there is no difference in  available  functionality  between  basic  and  extended</span></span>
<span class="line"><span style="color: #c9d1d9">    syntaxes.   In  other implementations, basic regular expressions are less powerful.  The following description</span></span>
<span class="line"><span style="color: #c9d1d9">    applies to extended regular expressions; differences for basic regular expressions are summarized  afterwards.</span></span>
<span class="line"><span style="color: #c9d1d9">    Perl-compatible  regular  expressions  give  additional functionality, and are documented in pcresyntax(3) and</span></span>
<span class="line"><span style="color: #c9d1d9">    pcrepattern(3), but work only if PCRE is available in the system.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">    The fundamental building blocks are the regular expressions that match a single character.   Most  characters,</span></span>
<span class="line"><span style="color: #c9d1d9">    including  all  letters  and  digits,  are regular expressions that match themselves.  Any meta-character with</span></span>
<span class="line"><span style="color: #c9d1d9">    special meaning may be quoted by preceding it with a backslash.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">    The period . matches any single character.  It is unspecified whether it matches an encoding error.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">Character Classes and Bracket Expressions</span></span>
<span class="line"><span style="color: #c9d1d9">    A bracket expression is a list of characters enclosed by [ and ].  It matches any  single  character  in  that</span></span>
<span class="line"><span style="color: #c9d1d9">    list.   If the first character of the list is the caret ^ then it matches any character not in the list; it is</span></span>
<span class="line"><span style="color: #c9d1d9">    unspecified whether it matches an encoding error.  For example, the regular  expression  [0123456789]  matches</span></span>
<span class="line"><span style="color: #c9d1d9">    any single digit.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">    Within  a bracket expression, a range expression consists of two characters separated by a hyphen.  It matches</span></span>
<span class="line"><span style="color: #c9d1d9">    any single character that sorts between the two characters, inclusive, using the locale's  collating  sequence</span></span>
<span class="line"><span style="color: #c9d1d9">    and  character  set.   For example, in the default C locale, [a-d] is equivalent to [abcd].  Many locales sort</span></span>
<span class="line"><span style="color: #c9d1d9">    characters in dictionary order, and in these locales [a-d] is typically not equivalent to [abcd]; it might  be</span></span>
<span class="line"><span style="color: #c9d1d9">    equivalent  to  [aBbCcDd],  for example.  To obtain the traditional interpretation of bracket expressions, you</span></span>
<span class="line"><span style="color: #c9d1d9">    can use the C locale by setting the LC_ALL environment variable to the value C.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">    Finally, certain named classes of characters are predefined within bracket  expressions,  as  follows.   Their</span></span>
<span class="line"><span style="color: #c9d1d9">    names  are  self  explanatory,  and they are [:alnum:], [:alpha:], [:blank:], [:cntrl:], [:digit:], [:graph:],</span></span>
<span class="line"><span style="color: #c9d1d9">    [:lower:], [:print:], [:punct:], [:space:], [:upper:], and [:xdigit:].  For  example,  [[:alnum:]]  means  the</span></span>
<span class="line"><span style="color: #c9d1d9">    character  class  of  numbers  and  letters  in  the  current locale.  In the C locale and ASCII character set</span></span>
<span class="line"><span style="color: #c9d1d9">    encoding, this is the same as [0-9A-Za-z].  (Note that the brackets in these  class  names  are  part  of  the</span></span>
<span class="line"><span style="color: #c9d1d9">    symbolic  names,  and  must  be included in addition to the brackets delimiting the bracket expression.)  Most</span></span>
<span class="line"><span style="color: #c9d1d9">    meta-characters lose their special meaning inside bracket expressions.  To include a literal ] place it  first</span></span>
<span class="line"><span style="color: #c9d1d9">    in  the list.  Similarly, to include a literal ^ place it anywhere but first.  Finally, to include a literal -</span></span>
<span class="line"><span style="color: #c9d1d9">    place it last.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">Anchoring</span></span>
<span class="line"><span style="color: #c9d1d9">    The caret ^ and the dollar sign $ are  meta-characters  that  respectively  match  the  empty  string  at  the</span></span>
<span class="line"><span style="color: #c9d1d9">    beginning and end of a line.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">The Backslash Character and Special Expressions</span></span>
<span class="line"><span style="color: #c9d1d9">    The  symbols  \&#x3C; and \> respectively match the empty string at the beginning and end of a word.  The symbol \b</span></span>
<span class="line"><span style="color: #c9d1d9">    matches the empty string at the edge of a word, and \B matches the empty string provided it's not at the  edge</span></span>
<span class="line"><span style="color: #c9d1d9">    of a word.  The symbol \w is a synonym for [_[:alnum:]] and \W is a synonym for [^_[:alnum:]].</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">Repetition</span></span>
<span class="line"><span style="color: #c9d1d9">    A regular expression may be followed by one of several repetition operators:</span></span>
<span class="line"><span style="color: #c9d1d9">    ?      The preceding item is optional and matched at most once.</span></span>
<span class="line"><span style="color: #c9d1d9">    *      The preceding item will be matched zero or more times.</span></span>
<span class="line"><span style="color: #c9d1d9">    +      The preceding item will be matched one or more times.</span></span>
<span class="line"><span style="color: #c9d1d9">    {n}    The preceding item is matched exactly n times.</span></span>
<span class="line"><span style="color: #c9d1d9">    {n,}   The preceding item is matched n or more times.</span></span>
<span class="line"><span style="color: #c9d1d9">    {,m}   The preceding item is matched at most m times.  This is a GNU extension.</span></span>
<span class="line"><span style="color: #c9d1d9">    {n,m}  The preceding item is matched at least n times, but not more than m times.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">Concatenation</span></span>
<span class="line"><span style="color: #c9d1d9">    Two  regular  expressions  may  be concatenated; the resulting regular expression matches any string formed by</span></span>
<span class="line"><span style="color: #c9d1d9">    concatenating two substrings that respectively match the concatenated expressions.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">Alternation</span></span>
<span class="line"><span style="color: #c9d1d9">    Two regular expressions may be joined by the infix operator |; the resulting regular  expression  matches  any</span></span>
<span class="line"><span style="color: #c9d1d9">    string matching either alternate expression.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">Precedence</span></span>
<span class="line"><span style="color: #c9d1d9">    Repetition  takes  precedence  over  concatenation,  which in turn takes precedence over alternation.  A whole</span></span>
<span class="line"><span style="color: #c9d1d9">    expression may be enclosed in parentheses to override these precedence rules and form a subexpression.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">Back-references and Subexpressions</span></span>
<span class="line"><span style="color: #c9d1d9">    The back-reference \n, where n is a single  digit,  matches  the  substring  previously  matched  by  the  nth</span></span>
<span class="line"><span style="color: #c9d1d9">    parenthesized subexpression of the regular expression.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">Basic vs Extended Regular Expressions</span></span>
<span class="line"><span style="color: #c9d1d9">    In  basic regular expressions the meta-characters ?, +, {, |, (, and ) lose their special meaning; instead use</span></span>
<span class="line"><span style="color: #c9d1d9">    the backslashed versions \?, \+, \{, \|, \(, and \).</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">EXIT STATUS</span></span>
<span class="line"><span style="color: #c9d1d9">    Normally the exit status is 0 if a line is selected, 1 if no lines were selected, and 2 if an error  occurred.</span></span>
<span class="line"><span style="color: #c9d1d9">    However,  if  the  -q  or  --quiet or --silent is used and a line is selected, the exit status is 0 even if an</span></span>
<span class="line"><span style="color: #c9d1d9">    error occurred.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">ENVIRONMENT</span></span>
<span class="line"><span style="color: #c9d1d9">    The behavior of grep is affected by the following environment variables.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">    The locale for category LC_foo is specified by examining the three environment variables LC_ALL, LC_foo, LANG,</span></span>
<span class="line"><span style="color: #c9d1d9">    in  that order.  The first of these variables that is set specifies the locale.  For example, if LC_ALL is not</span></span>
<span class="line"><span style="color: #c9d1d9">    set, but LC_MESSAGES is set to pt_BR, then the  Brazilian  Portuguese  locale  is  used  for  the  LC_MESSAGES</span></span>
<span class="line"><span style="color: #c9d1d9">    category.   The  C locale is used if none of these environment variables are set, if the locale catalog is not</span></span>
<span class="line"><span style="color: #c9d1d9">    installed, or if grep was not compiled with national language support (NLS).   The  shell  command  locale  -a</span></span>
<span class="line"><span style="color: #c9d1d9">    lists locales that are currently available.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">    GREP_COLOR</span></span>
<span class="line"><span style="color: #c9d1d9">            This  variable  specifies  the  color  used to highlight matched (non-empty) text.  It is deprecated in</span></span>
<span class="line"><span style="color: #c9d1d9">            favor of GREP_COLORS, but still supported.  The  mt,  ms,  and  mc  capabilities  of  GREP_COLORS  have</span></span>
<span class="line"><span style="color: #c9d1d9">            priority  over  it.  It can only specify the color used to highlight the matching non-empty text in any</span></span>
<span class="line"><span style="color: #c9d1d9">            matching line (a selected line when the -v command-line option is omitted, or a context line when -v is</span></span>
<span class="line"><span style="color: #c9d1d9">            specified).   The  default  is  01;31, which means a bold red foreground text on the terminal's default</span></span>
<span class="line"><span style="color: #c9d1d9">            background.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">    GREP_COLORS</span></span>
<span class="line"><span style="color: #c9d1d9">            Specifies the colors and other attributes used to highlight various parts of the output.  Its value  is</span></span>
<span class="line"><span style="color: #c9d1d9">            a        colon-separated        list        of        capabilities        that        defaults       to</span></span>
<span class="line"><span style="color: #c9d1d9">            ms=01;31:mc=01;31:sl=:cx=:fn=35:ln=32:bn=32:se=36 with the  rv  and  ne  boolean  capabilities  omitted</span></span>
<span class="line"><span style="color: #c9d1d9">            (i.e., false).  Supported capabilities are as follows.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">            sl=    SGR  substring for whole selected lines (i.e., matching lines when the -v command-line option is</span></span>
<span class="line"><span style="color: #c9d1d9">                    omitted, or non-matching lines when -v is specified).  If however the boolean rv capability  and</span></span>
<span class="line"><span style="color: #c9d1d9">                    the  -v  command-line  option  are both specified, it applies to context matching lines instead.</span></span>
<span class="line"><span style="color: #c9d1d9">                    The default is empty (i.e., the terminal's default color pair).</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">            cx=    SGR substring for whole context lines (i.e., non-matching lines when the -v command-line  option</span></span>
<span class="line"><span style="color: #c9d1d9">                    is  omitted,  or matching lines when -v is specified).  If however the boolean rv capability and</span></span>
<span class="line"><span style="color: #c9d1d9">                    the -v command-line option are  both  specified,  it  applies  to  selected  non-matching  lines</span></span>
<span class="line"><span style="color: #c9d1d9">                    instead.  The default is empty (i.e., the terminal's default color pair).</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">            rv     Boolean  value  that  reverses  (swaps) the meanings of the sl= and cx= capabilities when the -v</span></span>
<span class="line"><span style="color: #c9d1d9">                    command-line option is specified.  The default is false (i.e., the capability is omitted).</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">            mt=01;31</span></span>
<span class="line"><span style="color: #c9d1d9">                    SGR substring for matching non-empty text in any matching line (i.e., a selected line  when  the</span></span>
<span class="line"><span style="color: #c9d1d9">                    -v  command-line  option  is  omitted, or a context line when -v is specified).  Setting this is</span></span>
<span class="line"><span style="color: #c9d1d9">                    equivalent to setting both ms= and mc= at once to the same value.  The default  is  a  bold  red</span></span>
<span class="line"><span style="color: #c9d1d9">                    text foreground over the current line background.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">            ms=01;31</span></span>
<span class="line"><span style="color: #c9d1d9">                    SGR  substring  for  matching non-empty text in a selected line.  (This is only used when the -v</span></span>
<span class="line"><span style="color: #c9d1d9">                    command-line option is omitted.)  The effect of the sl= (or cx= if rv) capability remains active</span></span>
<span class="line"><span style="color: #c9d1d9">                    when this kicks in.  The default is a bold red text foreground over the current line background.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">            mc=01;31</span></span>
<span class="line"><span style="color: #c9d1d9">                    SGR  substring  for  matching  non-empty text in a context line.  (This is only used when the -v</span></span>
<span class="line"><span style="color: #c9d1d9">                    command-line option is specified.)  The effect of the cx= (or  sl=  if  rv)  capability  remains</span></span>
<span class="line"><span style="color: #c9d1d9">                    active  when  this  kicks  in.   The default is a bold red text foreground over the current line</span></span>
<span class="line"><span style="color: #c9d1d9">                    background.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">            fn=35  SGR substring for file names prefixing  any  content  line.   The  default  is  a  magenta  text</span></span>
<span class="line"><span style="color: #c9d1d9">                    foreground over the terminal's default background.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">            ln=32  SGR  substring  for  line  numbers  prefixing  any  content  line.   The default is a green text</span></span>
<span class="line"><span style="color: #c9d1d9">                    foreground over the terminal's default background.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">            bn=32  SGR substring for byte offsets prefixing  any  content  line.   The  default  is  a  green  text</span></span>
<span class="line"><span style="color: #c9d1d9">                    foreground over the terminal's default background.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">            se=36  SGR substring for separators that are inserted between selected line fields (:), between context</span></span>
<span class="line"><span style="color: #c9d1d9">                    line fields, (-), and between groups of adjacent lines when nonzero context is  specified  (--).</span></span>
<span class="line"><span style="color: #c9d1d9">                    The default is a cyan text foreground over the terminal's default background.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">            ne     Boolean  value  that  prevents  clearing  to  the  end of line using Erase in Line (EL) to Right</span></span>
<span class="line"><span style="color: #c9d1d9">                    (\33[K) each time a colorized item ends.  This is  needed  on  terminals  on  which  EL  is  not</span></span>
<span class="line"><span style="color: #c9d1d9">                    supported.   It  is  otherwise  useful on terminals for which the back_color_erase (bce) boolean</span></span>
<span class="line"><span style="color: #c9d1d9">                    terminfo capability does not  apply,  when  the  chosen  highlight  colors  do  not  affect  the</span></span>
<span class="line"><span style="color: #c9d1d9">                    background,  or when EL is too slow or causes too much flicker.  The default is false (i.e., the</span></span>
<span class="line"><span style="color: #c9d1d9">                    capability is omitted).</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">            Note that boolean capabilities have no =... part.  They are omitted (i.e., false) by default and become</span></span>
<span class="line"><span style="color: #c9d1d9">            true when specified.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">            See  the  Select Graphic Rendition (SGR) section in the documentation of the text terminal that is used</span></span>
<span class="line"><span style="color: #c9d1d9">            for permitted values and their meaning as character attributes.  These substring values are integers in</span></span>
<span class="line"><span style="color: #c9d1d9">            decimal  representation  and  can  be  concatenated with semicolons.  grep takes care of assembling the</span></span>
<span class="line"><span style="color: #c9d1d9">            result into a complete SGR sequence (\33[...m).  Common values to concatenate include 1 for bold, 4 for</span></span>
<span class="line"><span style="color: #c9d1d9">            underline, 5 for blink, 7 for inverse, 39 for default foreground color, 30 to 37 for foreground colors,</span></span>
<span class="line"><span style="color: #c9d1d9">            90 to 97 for 16-color mode foreground colors, 38;5;0 to  38;5;255  for  88-color  and  256-color  modes</span></span>
<span class="line"><span style="color: #c9d1d9">            foreground  colors,  49  for  default  background color, 40 to 47 for background colors, 100 to 107 for</span></span>
<span class="line"><span style="color: #c9d1d9">            16-color mode background colors, and 48;5;0 to 48;5;255 for 88-color  and  256-color  modes  background</span></span>
<span class="line"><span style="color: #c9d1d9">            colors.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">    LC_ALL, LC_COLLATE, LANG</span></span>
<span class="line"><span style="color: #c9d1d9">            These variables specify the locale for the LC_COLLATE category, which determines the collating sequence</span></span>
<span class="line"><span style="color: #c9d1d9">            used to interpret range expressions like [a-z].</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">    LC_ALL, LC_CTYPE, LANG</span></span>
<span class="line"><span style="color: #c9d1d9">            These variables specify the locale for the LC_CTYPE category, which determines the type of  characters,</span></span>
<span class="line"><span style="color: #c9d1d9">            e.g.,  which characters are whitespace.  This category also determines the character encoding, that is,</span></span>
<span class="line"><span style="color: #c9d1d9">            whether text is encoded in UTF-8, ASCII, or some other  encoding.   In  the  C  or  POSIX  locale,  all</span></span>
<span class="line"><span style="color: #c9d1d9">            characters are encoded as a single byte and every byte is a valid character.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">    LC_ALL, LC_MESSAGES, LANG</span></span>
<span class="line"><span style="color: #c9d1d9">            These  variables  specify  the  locale for the LC_MESSAGES category, which determines the language that</span></span>
<span class="line"><span style="color: #c9d1d9">            grep uses for messages.  The default C locale uses American English messages.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">    POSIXLY_CORRECT</span></span>
<span class="line"><span style="color: #c9d1d9">            If set, grep behaves as POSIX requires; otherwise, grep behaves more like other  GNU  programs.   POSIX</span></span>
<span class="line"><span style="color: #c9d1d9">            requires  that  options  that follow file names must be treated as file names; by default, such options</span></span>
<span class="line"><span style="color: #c9d1d9">            are permuted to the front of the operand list and are treated as options.  Also,  POSIX  requires  that</span></span>
<span class="line"><span style="color: #c9d1d9">            unrecognized  options  be  diagnosed  as  “illegal”,  but since they are not really against the law the</span></span>
<span class="line"><span style="color: #c9d1d9">            default is to diagnose them as “invalid”.  POSIXLY_CORRECT also disables  _N_GNU_nonoption_argv_flags_,</span></span>
<span class="line"><span style="color: #c9d1d9">            described below.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">    _N_GNU_nonoption_argv_flags_</span></span>
<span class="line"><span style="color: #c9d1d9">            (Here N is grep's numeric process ID.)  If the ith character of this environment variable's value is 1,</span></span>
<span class="line"><span style="color: #c9d1d9">            do not consider the ith operand of grep to be an option, even if it appears to be one.  A shell can put</span></span>
<span class="line"><span style="color: #c9d1d9">            this variable in the environment for each command it runs, specifying which operands are the results of</span></span>
<span class="line"><span style="color: #c9d1d9">            file name wildcard expansion and therefore  should  not  be  treated  as  options.   This  behavior  is</span></span>
<span class="line"><span style="color: #c9d1d9">            available only with the GNU C library, and only when POSIXLY_CORRECT is not set.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">NOTES</span></span>
<span class="line"><span style="color: #c9d1d9">    This man page is maintained only fitfully; the full documentation is often more up-to-date.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">COPYRIGHT</span></span>
<span class="line"><span style="color: #c9d1d9">    Copyright 1998-2000, 2002, 2005-2020 Free Software Foundation, Inc.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">    This  is  free  software;  see  the  source  for  copying  conditions.   There  is  NO  warranty; not even for</span></span>
<span class="line"><span style="color: #c9d1d9">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">BUGS</span></span>
<span class="line"><span style="color: #c9d1d9">Reporting Bugs</span></span>
<span class="line"><span style="color: #c9d1d9">    Email   bug   reports   to   the    bug-reporting    address    ⟨bug-grep@gnu.org⟩.     An    email    archive</span></span>
<span class="line"><span style="color: #c9d1d9">    ⟨https://lists.gnu.org/mailman/listinfo/bug-grep⟩            and            a            bug           tracker</span></span>
<span class="line"><span style="color: #c9d1d9">    ⟨https://debbugs.gnu.org/cgi/pkgreport.cgi?package=grep⟩ are available.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">Known Bugs</span></span>
<span class="line"><span style="color: #c9d1d9">    Large repetition counts in the {n,m} construct may cause grep to use lots of  memory.   In  addition,  certain</span></span>
<span class="line"><span style="color: #c9d1d9">    other obscure regular expressions require exponential time and space, and may cause grep to run out of memory.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">    Back-references are very slow, and may require exponential time.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">EXAMPLE</span></span>
<span class="line"><span style="color: #c9d1d9">    The  following example outputs the location and contents of any line containing “f” and ending in “.c”, within</span></span>
<span class="line"><span style="color: #c9d1d9">    all files in the current directory whose names contain “g” and end in “.h”.  The -n option outputs  line  num‐</span></span>
<span class="line"><span style="color: #c9d1d9">    bers,  the -- argument treats expansions of “*g*.h” starting with “-” as file names not options, and the empty</span></span>
<span class="line"><span style="color: #c9d1d9">    file /dev/null causes file names to be output even if only one file name happens to be of the form “*g*.h”.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">        $ grep -n -- 'f.*\.c$' *g*.h /dev/null</span></span>
<span class="line"><span style="color: #c9d1d9">        argmatch.h:1:/* definitions and prototypes for argmatch.c</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">    The only line that matches is line 1 of argmatch.h.  Note that the regular expression syntax used in the  pat‐</span></span>
<span class="line"><span style="color: #c9d1d9">    tern differs from the globbing syntax that the shell uses to match file names.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">SEE ALSO</span></span>
<span class="line"><span style="color: #c9d1d9">Regular Manual Pages</span></span>
<span class="line"><span style="color: #c9d1d9">    awk(1),  cmp(1),  diff(1),  find(1),  perl(1),  sed(1),  sort(1),  xargs(1),  read(2), pcre(3), pcresyntax(3),</span></span>
<span class="line"><span style="color: #c9d1d9">    pcrepattern(3), terminfo(5), glob(7), regex(7).</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">Full Documentation</span></span>
<span class="line"><span style="color: #c9d1d9">    A complete manual ⟨https://www.gnu.org/software/grep/manual/⟩ is available.  If the info and grep programs are</span></span>
<span class="line"><span style="color: #c9d1d9">    properly installed at your site, the command</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">            info grep</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">    should give you access to the complete manual.</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">GNU grep 3.6                                          2019-12-29                                              GREP(1)</span></span></code></pre>
<h2 id="what-is-regex">What is REGEX</h2>
<p><strong>Regex</strong>, or <strong>Reg</strong>ular <strong>Ex</strong>pression, is a way of writing search queries that look for specific phrases. A regex expression is a form of pattern matching. For the purpose of this article we will skip the regex tutorial.</p>
<p>Here are some basics for a recap.</p>
<h3 id="anchors">Anchors</h3>
<p>These are expressions that signify a position as a condition. Using one of these means that for there to be a match then you must find the particular phrase in the required position. For example, when we use <code>^</code> we are signifying that the phrase after it must be at the beginning of any match. Say <code>^c</code> would be true for <code>chris</code> but would be false for <code>back</code>. In the first case we have the word <code>chris</code> which begins with a c. This provides a match and thus is true for the regex of <code>^c</code>. Since <code>back</code> only contains a c at the end it does not satisfy the case of <code>^c</code>.</p>








































<table><thead><tr><th>Expression</th><th>Description</th><th>Example</th></tr></thead><tbody><tr><td>^[exp]</td><td>Start</td><td>^a  - “Hola <u><strong>a</strong></u>migo”</td></tr><tr><td>\A[exp]</td><td>Start</td><td>\Aa - “Hola <u><strong>a</strong></u>migo”</td></tr><tr><td>[exp]$</td><td>End</td><td>d$  - “Hello Worl<u><strong>d</strong></u>”</td></tr><tr><td>[exp]\Z</td><td>End</td><td>d\Z - “Hello Worl<u><strong>d</strong></u>”</td></tr><tr><td>\b[exp]\b</td><td>Word Boundary</td><td>\bme\b - ”<u><strong>me</strong></u> not some”</td></tr><tr><td>\B[exp]\B</td><td>Not Word Boundary</td><td>\Bme\B - “Ho<u><strong>me</strong></u>r not me or some”</td></tr></tbody></table>
<p><em>Note: The use of [exp] is designed to represent a standalone expression. This should not be confused wtih the actual brackets notation.</em></p>
<p>Let’s look at those work boudaries. They are a bit strange but useful. If a word is a group of letters then a word boundary is the edge of that word. In other words, a letter next to a space would be a word boundary. <code>/b</code> is a word boundary. The side of the expression you apply /b to is the side of the expression that you want a boundary on. If both side have a boundary then you can safely say you are looking for an exact word match. This looks like <code>/bword\b</code>. If we want a phrase that ends with an expression then we can use <code>[exp]\b</code>.</p>
<p>TODO: add some examples of these being demonstrated in the console. Python or JS regex.</p>
			</article>
		</main>
		<footer class="astro-SZ7XMLTE">
	&copy; 2023 Christopher Carlin. All rights reserved.
</footer>
	</body></html>